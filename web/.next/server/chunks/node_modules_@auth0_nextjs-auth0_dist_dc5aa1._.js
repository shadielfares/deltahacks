module.exports = {

"[project]/node_modules/@auth0/nextjs-auth0/dist/session/session.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fromJson = exports.fromTokenEndpointResponse = void 0;
const tslib_1 = __turbopack_require__("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const jose = tslib_1.__importStar(__turbopack_require__("[project]/node_modules/jose/dist/node/cjs/index.js [app-route] (ecmascript)"));
/**
 * The user's session.
 *
 * @category Server
 */ class Session {
    constructor(user){
        this.user = user;
    }
}
exports.default = Session;
/**
 * @ignore
 */ function fromTokenEndpointResponse(tokenEndpointResponse, config) {
    // Get the claims without any OIDC-specific claim.
    const claims = jose.decodeJwt(tokenEndpointResponse.id_token);
    config.identityClaimFilter.forEach((claim)=>{
        delete claims[claim];
    });
    const { id_token, access_token, scope, expires_in, expires_at, refresh_token } = tokenEndpointResponse, remainder = tslib_1.__rest(tokenEndpointResponse, [
        "id_token",
        "access_token",
        "scope",
        "expires_in",
        "expires_at",
        "refresh_token"
    ]);
    const storeIDToken = config.session.storeIDToken;
    return Object.assign(new Session(Object.assign({}, claims)), Object.assign({
        accessToken: access_token,
        accessTokenScope: scope,
        accessTokenExpiresAt: Math.floor(Date.now() / 1000) + Number(expires_in),
        refreshToken: refresh_token
    }, storeIDToken && {
        idToken: id_token
    }), remainder);
}
exports.fromTokenEndpointResponse = fromTokenEndpointResponse;
/**
 * @ignore
 */ function fromJson(json) {
    if (!json) {
        return null;
    }
    return Object.assign(new Session(Object.assign({}, json.user)), json);
}
exports.fromJson = fromJson; //# sourceMappingURL=session.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/session/get-session.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const session_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/session/index.js [app-route] (ecmascript)");
/**
 * @ignore
 */ function sessionFactory(sessionCache) {
    return async (req, res)=>{
        const [session] = await (0, session_1.get)({
            req,
            res,
            sessionCache
        });
        return session;
    };
}
exports.default = sessionFactory; //# sourceMappingURL=get-session.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/utils/errors.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ProfileHandlerError = exports.LogoutHandlerError = exports.LoginHandlerError = exports.CallbackHandlerError = exports.HandlerError = exports.AccessTokenError = exports.AccessTokenErrorCode = exports.AuthError = exports.appendCause = void 0;
/**
 * @ignore
 */ function appendCause(errorMessage, cause) {
    if (!cause) return errorMessage;
    const separator = errorMessage.endsWith('.') ? '' : '.';
    return `${errorMessage}${separator} CAUSE: ${cause.message}`;
}
exports.appendCause = appendCause;
/**
 * The base class for all SDK errors.
 *
 * Because part of the error message can come from the OpenID Connect `error` query parameter we
 * do some basic escaping which makes sure the default error handler is safe from XSS.
 *
 * **IMPORTANT** If you write your own error handler, you should **not** render the error
 * without using a templating engine that will properly escape it for other HTML contexts first.
 *
 * Note that the error message of the {@link AuthError.cause | underlying error} is **not** escaped
 * in any way, so do **not** render it without escaping it first!
 *
 * @category Server
 */ class AuthError extends Error {
    constructor(options){
        /* c8 ignore next */ super(appendCause(options.message, options.cause));
        this.code = options.code;
        this.name = options.name;
        this.cause = options.cause;
        this.status = options.status;
    }
}
exports.AuthError = AuthError;
/**
 * Error codes for {@link AccessTokenError}.
 *
 * @category Server
 */ var AccessTokenErrorCode;
(function(AccessTokenErrorCode) {
    AccessTokenErrorCode["MISSING_SESSION"] = "ERR_MISSING_SESSION";
    AccessTokenErrorCode["MISSING_ACCESS_TOKEN"] = "ERR_MISSING_ACCESS_TOKEN";
    AccessTokenErrorCode["MISSING_REFRESH_TOKEN"] = "ERR_MISSING_REFRESH_TOKEN";
    AccessTokenErrorCode["EXPIRED_ACCESS_TOKEN"] = "ERR_EXPIRED_ACCESS_TOKEN";
    AccessTokenErrorCode["INSUFFICIENT_SCOPE"] = "ERR_INSUFFICIENT_SCOPE";
    AccessTokenErrorCode["FAILED_REFRESH_GRANT"] = "ERR_FAILED_REFRESH_GRANT";
})(AccessTokenErrorCode = exports.AccessTokenErrorCode || (exports.AccessTokenErrorCode = {}));
/**
 * The error thrown by {@link GetAccessToken}.
 *
 * @see the {@link AuthError.code | code property} contains a machine-readable error code that
 * remains stable within a major version of the SDK. You should rely on this error code to handle
 * errors. In contrast, the error message is not part of the API and can change anytime. Do **not**
 * parse or otherwise rely on the error message to handle errors.
 *
 * @see {@link AccessTokenErrorCode} for the list of all possible error codes.
 * @category Server
 */ class AccessTokenError extends AuthError {
    constructor(code, message, cause){
        /* c8 ignore next */ super({
            code: code,
            message: message,
            name: 'AccessTokenError',
            cause
        });
        // Capturing stack trace, excluding constructor call from it.
        Error.captureStackTrace(this, this.constructor);
        Object.setPrototypeOf(this, AccessTokenError.prototype);
    }
}
exports.AccessTokenError = AccessTokenError;
/**
 * The base class for errors thrown by API route handlers. It extends {@link AuthError}.
 *
 * Because part of the error message can come from the OpenID Connect `error` query parameter we
 * do some basic escaping which makes sure the default error handler is safe from XSS.
 *
 * **IMPORTANT** If you write your own error handler, you should **not** render the error message
 * without using a templating engine that will properly escape it for other HTML contexts first.
 *
 * @see the {@link AuthError.cause | cause property} contains the underlying error.
 * **IMPORTANT** When this error is from the Identity Provider ({@link IdentityProviderError}) it can contain user
 * input and is only escaped using basic escaping for putting untrusted data directly into the HTML body.
 * You should **not** render this error without using a templating engine that will properly escape it for other
 * HTML contexts first.
 *
 * @see the {@link AuthError.status | status property} contains the HTTP status code of the error,
 * if any.
 *
 * @category Server
 */ class HandlerError extends AuthError {
    constructor(options){
        let status;
        if ('status' in options.cause) status = options.cause.status;
        /* c8 ignore next */ super(Object.assign(Object.assign({}, options), {
            status
        }));
    }
}
exports.HandlerError = HandlerError;
/**
 * The error thrown by the callback API route handler. It extends {@link HandlerError}.
 *
 * Because part of the error message can come from the OpenID Connect `error` query parameter we
 * do some basic escaping which makes sure the default error handler is safe from XSS.
 *
 * **IMPORTANT** If you write your own error handler, you should **not** render the error message
 * without using a templating engine that will properly escape it for other HTML contexts first.
 *
 * @see the {@link AuthError.cause | cause property} contains the underlying error.
 * **IMPORTANT** When this error is from the Identity Provider ({@link IdentityProviderError}) it can contain user
 * input and is only escaped using basic escaping for putting untrusted data directly into the HTML body.
 * You should **not** render this error without using a templating engine that will properly escape it for other
 * HTML contexts first.
 *
 * @see the {@link AuthError.status | status property} contains the HTTP status code of the error,
 * if any.
 *
 * @category Server
 */ class CallbackHandlerError extends HandlerError {
    constructor(cause){
        super({
            code: CallbackHandlerError.code,
            message: 'Callback handler failed.',
            name: 'CallbackHandlerError',
            cause
        }); /* c8 ignore next */ 
        Object.setPrototypeOf(this, CallbackHandlerError.prototype);
    }
}
exports.CallbackHandlerError = CallbackHandlerError;
CallbackHandlerError.code = 'ERR_CALLBACK_HANDLER_FAILURE';
/**
 * The error thrown by the login API route handler. It extends {@link HandlerError}.
 *
 * @see the {@link AuthError.cause | cause property} contains the underlying error.
 * @category Server
 */ class LoginHandlerError extends HandlerError {
    constructor(cause){
        super({
            code: LoginHandlerError.code,
            message: 'Login handler failed.',
            name: 'LoginHandlerError',
            cause
        }); /* c8 ignore next */ 
        Object.setPrototypeOf(this, LoginHandlerError.prototype);
    }
}
exports.LoginHandlerError = LoginHandlerError;
LoginHandlerError.code = 'ERR_LOGIN_HANDLER_FAILURE';
/**
 * The error thrown by the logout API route handler. It extends {@link HandlerError}.
 *
 * @see the {@link AuthError.cause | cause property} contains the underlying error.
 * @category Server
 */ class LogoutHandlerError extends HandlerError {
    constructor(cause){
        super({
            code: LogoutHandlerError.code,
            message: 'Logout handler failed.',
            name: 'LogoutHandlerError',
            cause
        }); /* c8 ignore next */ 
        Object.setPrototypeOf(this, LogoutHandlerError.prototype);
    }
}
exports.LogoutHandlerError = LogoutHandlerError;
LogoutHandlerError.code = 'ERR_LOGOUT_HANDLER_FAILURE';
/**
 * The error thrown by the profile API route handler. It extends {@link HandlerError}.
 *
 * @see the {@link AuthError.cause | cause property} contains the underlying error.
 * @category Server
 */ class ProfileHandlerError extends HandlerError {
    constructor(cause){
        super({
            code: ProfileHandlerError.code,
            message: 'Profile handler failed.',
            name: 'ProfileHandlerError',
            cause
        }); /* c8 ignore next */ 
        Object.setPrototypeOf(this, ProfileHandlerError.prototype);
    }
}
exports.ProfileHandlerError = ProfileHandlerError;
ProfileHandlerError.code = 'ERR_PROFILE_HANDLER_FAILURE'; //# sourceMappingURL=errors.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/utils/array.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.match = exports.intersect = void 0;
function intersect(a, b) {
    const set1 = new Set(a);
    const set2 = new Set(b);
    return new Set([
        ...set1
    ].filter((x)=>set2.has(x)));
}
exports.intersect = intersect;
function match(arr1, arr2) {
    const set1 = new Set(arr1);
    const set2 = new Set(arr2);
    if (set1.size !== set2.size) {
        return false;
    }
    for(let i = 0; i < arr1.length; i += 1){
        const item = arr1[i];
        if (!set2.has(item)) {
            return false;
        }
    }
    return true;
}
exports.match = match; //# sourceMappingURL=array.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/utils/errors.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.htmlSafe = exports.BackchannelLogoutError = exports.UserInfoError = exports.DiscoveryError = exports.IdentityProviderError = exports.ApplicationError = exports.MissingStateCookieError = exports.MalformedStateCookieError = exports.MissingStateParamError = exports.EscapedError = void 0;
class EscapedError extends Error {
    /**
     * **WARNING** The message can contain user input and is only escaped using basic escaping for putting untrusted data
     * directly into the HTML body
     */ constructor(message){
        /* c8 ignore next */ super(htmlSafe(message));
        Object.setPrototypeOf(this, EscapedError.prototype);
    }
}
exports.EscapedError = EscapedError;
class MissingStateParamError extends Error {
    constructor(){
        /* c8 ignore next */ super(MissingStateParamError.message);
        this.status = 400;
        this.statusCode = 400;
        Object.setPrototypeOf(this, MissingStateParamError.prototype);
    }
}
exports.MissingStateParamError = MissingStateParamError;
MissingStateParamError.message = 'Missing state parameter in Authorization Response.';
class MalformedStateCookieError extends Error {
    constructor(){
        /* c8 ignore next */ super(MalformedStateCookieError.message);
        this.status = 400;
        this.statusCode = 400;
        Object.setPrototypeOf(this, MalformedStateCookieError.prototype);
    }
}
exports.MalformedStateCookieError = MalformedStateCookieError;
MalformedStateCookieError.message = 'Your state cookie is not valid JSON.';
class MissingStateCookieError extends Error {
    constructor(){
        /* c8 ignore next */ super(MissingStateCookieError.message);
        this.status = 400;
        this.statusCode = 400;
        Object.setPrototypeOf(this, MissingStateCookieError.prototype);
    }
}
exports.MissingStateCookieError = MissingStateCookieError;
MissingStateCookieError.message = 'Missing state cookie from login request (check login URL, callback URL and cookie config).';
class ApplicationError extends EscapedError {
    /**
     * **WARNING** The message can contain user input and is only escaped using basic escaping for putting untrusted data
     * directly into the HTML body
     */ constructor(rpError){
        /* c8 ignore next */ super(rpError.message);
        Object.setPrototypeOf(this, ApplicationError.prototype);
    }
}
exports.ApplicationError = ApplicationError;
class IdentityProviderError extends EscapedError {
    /**
     * **WARNING** The message can contain user input and is only escaped using basic escaping for putting untrusted data
     * directly into the HTML body
     */ constructor(rpError){
        /* c8 ignore next */ super(rpError.message);
        this.error = htmlSafe(rpError.error);
        this.errorDescription = htmlSafe(rpError.error_description);
        Object.setPrototypeOf(this, IdentityProviderError.prototype);
    }
}
exports.IdentityProviderError = IdentityProviderError;
class DiscoveryError extends EscapedError {
    constructor(error, issuerBaseUrl){
        /* c8 ignore next */ super(`Discovery requests failing for ${issuerBaseUrl}, ${error.message}`);
        Object.setPrototypeOf(this, DiscoveryError.prototype);
    }
}
exports.DiscoveryError = DiscoveryError;
class UserInfoError extends EscapedError {
    constructor(msg){
        /* c8 ignore next */ super(`Userinfo request failing with: ${msg}`);
        Object.setPrototypeOf(this, UserInfoError.prototype);
    }
}
exports.UserInfoError = UserInfoError;
class BackchannelLogoutError extends Error {
    constructor(code, description){
        /* c8 ignore next */ super(description);
        this.code = code;
        this.description = description;
        Object.setPrototypeOf(this, BackchannelLogoutError.prototype);
    }
}
exports.BackchannelLogoutError = BackchannelLogoutError;
// eslint-disable-next-line max-len
// Basic escaping for putting untrusted data directly into the HTML body, per: https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html#rule-1-html-encode-before-inserting-untrusted-data-into-html-element-content.
function htmlSafe(input) {
    return input && input.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
}
exports.htmlSafe = htmlSafe; //# sourceMappingURL=errors.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/utils/debug.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const tslib_1 = __turbopack_require__("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const debug_1 = tslib_1.__importDefault(__turbopack_require__("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)"));
exports.default = (name)=>(0, debug_1.default)('nextjs-auth0').extend(name); //# sourceMappingURL=debug.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/utils/hkdf.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.signing = exports.encryption = void 0;
const tslib_1 = __turbopack_require__("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const hkdf_1 = tslib_1.__importDefault(__turbopack_require__("[project]/node_modules/@panva/hkdf/dist/node/cjs/index.js [app-route] (ecmascript)"));
const BYTE_LENGTH = 32;
const ENCRYPTION_INFO = 'JWE CEK';
const SIGNING_INFO = 'JWS Cookie Signing';
const digest = 'sha256';
/**
 *
 * Derives appropriate sized keys from the end-user provided secret random string/passphrase using
 * HKDF (HMAC-based Extract-and-Expand Key Derivation Function) defined in RFC 8569.
 *
 * @see https://tools.ietf.org/html/rfc5869
 *
 */ const encryption = (secret)=>(0, hkdf_1.default)(digest, secret, '', ENCRYPTION_INFO, BYTE_LENGTH);
exports.encryption = encryption;
const signing = (secret)=>(0, hkdf_1.default)(digest, secret, '', SIGNING_INFO, BYTE_LENGTH);
exports.signing = signing; //# sourceMappingURL=hkdf.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/session/abstract-session.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AbstractSession = void 0;
const tslib_1 = __turbopack_require__("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const debug_1 = tslib_1.__importDefault(__turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/utils/debug.js [app-route] (ecmascript)"));
const debug = (0, debug_1.default)('session');
const epoch = ()=>Date.now() / 1000 | 0; // eslint-disable-line no-bitwise
const assert = (bool, msg)=>{
    if (!bool) {
        throw new Error(msg);
    }
};
class AbstractSession {
    constructor(getConfig){
        this.getConfig = typeof getConfig === 'function' ? getConfig : ()=>getConfig;
    }
    async read(req) {
        const config = await this.getConfig(req);
        const { rollingDuration, absoluteDuration } = config.session;
        try {
            const existingSessionValue = await this.getSession(req);
            if (existingSessionValue) {
                const { header, data } = existingSessionValue;
                const { iat, uat, exp } = header;
                // check that the existing session isn't expired based on options when it was established
                assert(exp > epoch(), 'it is expired based on options when it was established');
                // check that the existing session isn't expired based on current rollingDuration rules
                if (rollingDuration) {
                    assert(uat + rollingDuration > epoch(), 'it is expired based on current rollingDuration rules');
                }
                // check that the existing session isn't expired based on current absoluteDuration rules
                if (typeof absoluteDuration === 'number') {
                    assert(iat + absoluteDuration > epoch(), 'it is expired based on current absoluteDuration rules');
                }
                return [
                    data,
                    iat
                ];
            }
        } catch (err) {
            debug('error handling session %O', err);
        }
        return [];
    }
    async save(req, res, session, createdAt) {
        const config = await this.getConfig(req);
        const _a = config.session.cookie, { transient } = _a, cookieConfig = tslib_1.__rest(_a, [
            "transient"
        ]);
        if (!session) {
            await this.deleteSession(req, res, cookieConfig);
            return;
        }
        const isNewSession = typeof createdAt === 'undefined';
        const uat = epoch();
        const iat = typeof createdAt === 'number' ? createdAt : uat;
        const exp = this.calculateExp(iat, uat, config);
        const cookieOptions = Object.assign({}, cookieConfig);
        if (!transient) {
            cookieOptions.expires = new Date(exp * 1000);
        }
        await this.setSession(req, res, session, uat, iat, exp, cookieOptions, isNewSession);
    }
    calculateExp(iat, uat, config) {
        const { absoluteDuration } = config.session;
        const { rolling, rollingDuration } = config.session;
        if (typeof absoluteDuration !== 'number') {
            return uat + rollingDuration;
        }
        if (!rolling) {
            return iat + absoluteDuration;
        }
        return Math.min(uat + rollingDuration, iat + absoluteDuration);
    }
}
exports.AbstractSession = AbstractSession; //# sourceMappingURL=abstract-session.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/session/stateless-session.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StatelessSession = void 0;
const tslib_1 = __turbopack_require__("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const jose = tslib_1.__importStar(__turbopack_require__("[project]/node_modules/jose/dist/node/cjs/index.js [app-route] (ecmascript)"));
const cookie_1 = __turbopack_require__("[project]/node_modules/cookie/index.js [app-route] (ecmascript)");
const debug_1 = tslib_1.__importDefault(__turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/utils/debug.js [app-route] (ecmascript)"));
const hkdf_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/utils/hkdf.js [app-route] (ecmascript)");
const abstract_session_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/session/abstract-session.js [app-route] (ecmascript)");
const debug = (0, debug_1.default)('stateless-session');
const MAX_COOKIE_SIZE = 4096;
const alg = 'dir';
const enc = 'A256GCM';
const notNull = (value)=>value !== null;
class StatelessSession extends abstract_session_1.AbstractSession {
    constructor(config){
        super(config);
        this.config = config;
    }
    async getChunkSize(config) {
        if (this.chunkSize === undefined) {
            const _a = config.session, _b = _a.cookie, { transient } = _b, cookieConfig = tslib_1.__rest(_b, [
                "transient"
            ]), { name: sessionName } = _a;
            const cookieOptions = Object.assign({}, cookieConfig);
            if (!transient) {
                cookieOptions.expires = new Date();
            }
            const emptyCookie = (0, cookie_1.serialize)(`${sessionName}.0`, '', cookieOptions);
            this.chunkSize = MAX_COOKIE_SIZE - emptyCookie.length;
        }
        return this.chunkSize;
    }
    async getKeys(config) {
        if (!this.keys) {
            const secret = config.secret;
            const secrets = Array.isArray(secret) ? secret : [
                secret
            ];
            this.keys = await Promise.all(secrets.map(hkdf_1.encryption));
        }
        return this.keys;
    }
    async encrypt(payload, { iat, uat, exp }, key) {
        return await new jose.EncryptJWT(Object.assign({}, payload)).setProtectedHeader({
            alg,
            enc,
            uat,
            iat,
            exp
        }).encrypt(key);
    }
    async decrypt(jwe, keys) {
        let err;
        for (const key of keys){
            try {
                return await jose.jwtDecrypt(jwe, key);
            } catch (e) {
                err = e;
            }
        }
        throw err;
    }
    async getSession(req) {
        const config = await this.getConfig(req);
        const { name: sessionName } = config.session;
        const cookies = req.getCookies();
        let existingSessionValue;
        if (sessionName in cookies) {
            // get JWE from un-chunked session cookie
            debug('reading session from %s cookie', sessionName);
            existingSessionValue = cookies[sessionName];
        } else if (`${sessionName}.0` in cookies) {
            // get JWE from chunked session cookie
            // iterate all cookie names
            // match and filter for the ones that match sessionName.<number>
            // sort by chunk index
            // concat
            existingSessionValue = Object.entries(cookies).map(([cookie, value])=>{
                const match = cookie.match(`^${sessionName}\\.(\\d+)$`);
                if (match) {
                    return [
                        match[1],
                        value
                    ];
                }
                return null;
            }).filter(notNull).sort(([a], [b])=>{
                return parseInt(a, 10) - parseInt(b, 10);
            }).map(([i, chunk])=>{
                debug('reading session chunk from %s.%d cookie', sessionName, i);
                return chunk;
            }).join('');
        }
        if (existingSessionValue) {
            const keys = await this.getKeys(config);
            const { protectedHeader, payload } = await this.decrypt(existingSessionValue, keys);
            return {
                header: protectedHeader,
                data: payload
            };
        }
        return;
    }
    async setSession(req, res, session, uat, iat, exp, cookieOptions) {
        const config = await this.getConfig(req);
        const { name: sessionName } = config.session;
        const cookies = req.getCookies();
        debug('found session, creating signed session cookie(s) with name %o(.i)', sessionName);
        const [key] = await this.getKeys(config);
        const value = await this.encrypt(session, {
            iat,
            uat,
            exp
        }, key);
        const chunkSize = await this.getChunkSize(config);
        const chunkCount = Math.ceil(value.length / chunkSize);
        const existingCookies = new Set(Object.keys(cookies).filter((cookie)=>cookie.match(`^${sessionName}(?:\\.\\d)?$`)));
        if (chunkCount > 1) {
            debug('cookie size greater than %d, chunking', this.chunkSize);
            for(let i = 0; i < chunkCount; i++){
                const chunkValue = value.slice(i * chunkSize, (i + 1) * chunkSize);
                const chunkCookieName = `${sessionName}.${i}`;
                res.setCookie(chunkCookieName, chunkValue, cookieOptions);
                existingCookies.delete(chunkCookieName);
            }
        } else {
            res.setCookie(sessionName, value, cookieOptions);
            existingCookies.delete(sessionName);
        }
        // When the number of chunks changes due to the cookie size changing,
        // you need to delete any obsolete cookies.
        existingCookies.forEach((cookie)=>res.clearCookie(cookie, cookieOptions));
    }
    async deleteSession(req, res, cookieOptions) {
        const config = await this.getConfig(req);
        const { name: sessionName } = config.session;
        const cookies = req.getCookies();
        for (const cookieName of Object.keys(cookies)){
            if (cookieName.match(`^${sessionName}(?:\\.\\d)?$`)) {
                res.clearCookie(cookieName, cookieOptions);
            }
        }
    }
}
exports.StatelessSession = StatelessSession; //# sourceMappingURL=stateless-session.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/utils/signed-cookies.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.generateCookieValue = exports.getCookieValue = void 0;
const tslib_1 = __turbopack_require__("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const jose = tslib_1.__importStar(__turbopack_require__("[project]/node_modules/jose/dist/node/cjs/index.js [app-route] (ecmascript)"));
const getCookieValue = async (k, v, keys)=>{
    if (!v) {
        return undefined;
    }
    const [value, signature] = v.split('.');
    const flattenedJWS = {
        protected: jose.base64url.encode(JSON.stringify({
            alg: 'HS256',
            b64: false,
            crit: [
                'b64'
            ]
        })),
        payload: `${k}=${value}`,
        signature
    };
    for (const key of keys){
        try {
            await jose.flattenedVerify(flattenedJWS, key, {
                algorithms: [
                    'HS256'
                ]
            });
            return value;
        } catch (e) {}
    }
    return;
};
exports.getCookieValue = getCookieValue;
const generateCookieValue = async (cookie, value, key)=>{
    const { signature } = await new jose.FlattenedSign(new TextEncoder().encode(`${cookie}=${value}`)).setProtectedHeader({
        alg: 'HS256',
        b64: false,
        crit: [
            'b64'
        ]
    }).sign(key);
    return `${value}.${signature}`;
};
exports.generateCookieValue = generateCookieValue; //# sourceMappingURL=signed-cookies.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/session/stateful-session.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StatefulSession = void 0;
const tslib_1 = __turbopack_require__("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const debug_1 = tslib_1.__importDefault(__turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/utils/debug.js [app-route] (ecmascript)"));
const abstract_session_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/session/abstract-session.js [app-route] (ecmascript)");
const signed_cookies_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/utils/signed-cookies.js [app-route] (ecmascript)");
const hkdf_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/utils/hkdf.js [app-route] (ecmascript)");
const debug = (0, debug_1.default)('stateful-session');
class StatefulSession extends abstract_session_1.AbstractSession {
    async getStore(config) {
        if (!this.store) {
            this.store = config.session.store;
        }
        return this.store;
    }
    async getKeys(config) {
        if (!this.keys) {
            const secret = config.secret;
            const secrets = Array.isArray(secret) ? secret : [
                secret
            ];
            this.keys = await Promise.all(secrets.map(hkdf_1.signing));
        }
        return this.keys;
    }
    async getSession(req) {
        const config = await this.getConfig(req);
        const { name: sessionName } = config.session;
        const cookies = req.getCookies();
        const keys = await this.getKeys(config);
        const sessionId = await (0, signed_cookies_1.getCookieValue)(sessionName, cookies[sessionName], keys);
        if (sessionId) {
            const store = await this.getStore(config);
            debug('reading session from %s store', sessionId);
            return store.get(sessionId);
        }
        return;
    }
    async setSession(req, res, session, uat, iat, exp, cookieOptions, isNewSession) {
        const config = await this.getConfig(req);
        const store = await this.getStore(config);
        const { name: sessionName, genId } = config.session;
        const cookies = req.getCookies();
        const keys = await this.getKeys(config);
        let sessionId = await (0, signed_cookies_1.getCookieValue)(sessionName, cookies[sessionName], keys);
        // If this is a new session created by a new login we need to remove the old session
        // from the store and regenerate the session id to prevent session fixation issue.
        if (sessionId && isNewSession) {
            debug('regenerating session id %o to prevent session fixation', sessionId);
            await store.delete(sessionId);
            sessionId = undefined;
        }
        if (!sessionId) {
            sessionId = await genId(req, session);
            debug('generated new session id %o', sessionId);
        }
        debug('set session %o', sessionId);
        const cookieValue = await (0, signed_cookies_1.generateCookieValue)(sessionName, sessionId, keys[0]);
        res.setCookie(sessionName, cookieValue, cookieOptions);
        await store.set(sessionId, {
            header: {
                iat,
                uat,
                exp
            },
            data: session
        });
    }
    async deleteSession(req, res, cookieOptions) {
        const config = await this.getConfig(req);
        const { name: sessionName } = config.session;
        const cookies = req.getCookies();
        const keys = await this.getKeys(config);
        const sessionId = await (0, signed_cookies_1.getCookieValue)(sessionName, cookies[sessionName], keys);
        if (sessionId) {
            const store = await this.getStore(config);
            debug('deleting session %o', sessionId);
            res.clearCookie(sessionName, cookieOptions);
            await store.delete(sessionId);
        }
    }
}
exports.StatefulSession = StatefulSession; //# sourceMappingURL=stateful-session.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/transient-store.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const signed_cookies_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/utils/signed-cookies.js [app-route] (ecmascript)");
const hkdf_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/utils/hkdf.js [app-route] (ecmascript)");
class TransientStore {
    constructor(getConfig){
        this.getConfig = typeof getConfig === 'function' ? getConfig : ()=>getConfig;
    }
    async getKeys(config) {
        if (!this.keys) {
            const secret = config.secret;
            const secrets = Array.isArray(secret) ? secret : [
                secret
            ];
            this.keys = await Promise.all(secrets.map(hkdf_1.signing));
        }
        return this.keys;
    }
    /**
     * Set a cookie with a value or a generated nonce.
     *
     * @param {String} key Cookie name to use.
     * @param {IncomingMessage} req Server Request object.
     * @param {ServerResponse} res Server Response object.
     * @param {Object} opts Options object.
     * @param {String} opts.sameSite SameSite attribute of `None`, `Lax`, or `Strict`. Defaults to `None`.
     * @param {String} opts.value Cookie value. Omit this key to store a generated value.
     *
     * @return {String} Cookie value that was set.
     */ async save(key, req, res, { sameSite = 'none', value }) {
        const isSameSiteNone = sameSite === 'none';
        const config = await this.getConfig(req);
        const { domain, path, secure } = config.transactionCookie;
        const basicAttr = {
            httpOnly: true,
            secure,
            domain,
            path
        };
        const [signingKey] = await this.getKeys(config);
        {
            const cookieValue = await (0, signed_cookies_1.generateCookieValue)(key, value, signingKey);
            // Set the cookie with the SameSite attribute and, if needed, the Secure flag.
            res.setCookie(key, cookieValue, Object.assign(Object.assign({}, basicAttr), {
                sameSite,
                secure: isSameSiteNone ? true : basicAttr.secure
            }));
        }
        if (isSameSiteNone && config.legacySameSiteCookie) {
            const cookieValue = await (0, signed_cookies_1.generateCookieValue)(`_${key}`, value, signingKey);
            // Set the fallback cookie with no SameSite or Secure attributes.
            res.setCookie(`_${key}`, cookieValue, basicAttr);
        }
        return value;
    }
    /**
     * Get a cookie value then delete it.
     *
     * @param {String} key Cookie name to use.
     * @param {IncomingMessage} req Express Request object.
     * @param {ServerResponse} res Express Response object.
     *
     * @return {String|undefined} Cookie value or undefined if cookie was not found.
     */ async read(key, req, res) {
        const cookies = req.getCookies();
        const cookie = cookies[key];
        const config = await this.getConfig(req);
        const cookieConfig = config.transactionCookie;
        const verifyingKeys = await this.getKeys(config);
        let value = await (0, signed_cookies_1.getCookieValue)(key, cookie, verifyingKeys);
        res.clearCookie(key, cookieConfig);
        if (config.legacySameSiteCookie) {
            const fallbackKey = `_${key}`;
            if (!value) {
                const fallbackCookie = cookies[fallbackKey];
                value = await (0, signed_cookies_1.getCookieValue)(fallbackKey, fallbackCookie, verifyingKeys);
            }
            res.clearCookie(fallbackKey, cookieConfig);
        }
        return value;
    }
}
exports.default = TransientStore; //# sourceMappingURL=transient-store.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/hooks/get-login-state.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getLoginState = void 0;
const tslib_1 = __turbopack_require__("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const debug_1 = tslib_1.__importDefault(__turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/utils/debug.js [app-route] (ecmascript)"));
const debug = (0, debug_1.default)('get-login-state');
/**
 * Generate the state value for use during login transactions. It is used to store the intended
 * return URL after the user authenticates. State is not used to carry unique PRNG values here
 * because the library utilizes either nonce or PKCE for CSRF protection.
 *
 * @param {IncomingMessage} _req
 * @param {LoginOptions} options
 *
 * @return {object}
 */ const getLoginState = (options)=>{
    const state = {
        returnTo: options.returnTo
    };
    debug('adding default state %O', state);
    return state;
};
exports.getLoginState = getLoginState; //# sourceMappingURL=get-login-state.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/get-config.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.get = void 0;
const tslib_1 = __turbopack_require__("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const joi_1 = tslib_1.__importDefault(__turbopack_require__("[project]/node_modules/joi/lib/index.js [app-route] (ecmascript)"));
const get_login_state_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/hooks/get-login-state.js [app-route] (ecmascript)");
const isHttps = /^https:/i;
const paramsSchema = joi_1.default.object({
    secret: joi_1.default.alternatives([
        joi_1.default.string().min(8),
        joi_1.default.array().items(joi_1.default.string().min(8))
    ]).required(),
    session: joi_1.default.object({
        rolling: joi_1.default.boolean().optional().default(true),
        rollingDuration: joi_1.default.when(joi_1.default.ref('rolling'), {
            is: true,
            then: joi_1.default.number().integer().messages({
                'number.base': '"session.rollingDuration" must be provided an integer value when "session.rolling" is true'
            }),
            otherwise: joi_1.default.boolean().valid(false).messages({
                'any.only': '"session.rollingDuration" must be false when "session.rolling" is disabled'
            })
        }).optional().default((parent)=>parent.rolling ? 24 * 60 * 60 : false),
        absoluteDuration: joi_1.default.when(joi_1.default.ref('rolling'), {
            is: false,
            then: joi_1.default.number().integer().messages({
                'number.base': '"session.absoluteDuration" must be provided an integer value when "session.rolling" is false'
            }),
            otherwise: joi_1.default.alternatives([
                joi_1.default.number().integer(),
                joi_1.default.boolean().valid(false)
            ])
        }).optional().default(7 * 24 * 60 * 60),
        autoSave: joi_1.default.boolean().optional().default(true),
        name: joi_1.default.string().token().optional().default('appSession'),
        store: joi_1.default.object().optional().when(joi_1.default.ref('/backchannelLogout'), {
            not: false,
            then: joi_1.default.when('/backchannelLogout.store', {
                not: joi_1.default.exist(),
                then: joi_1.default.object().required().messages({
                    // eslint-disable-next-line max-len
                    'any.required': `Back-Channel Logout requires a "backchannelLogout.store" (you can also reuse "session.store" if you have stateful sessions).`
                })
            })
        }),
        genId: joi_1.default.function().maxArity(2).when(joi_1.default.ref('store'), {
            then: joi_1.default.required()
        }),
        storeIDToken: joi_1.default.boolean().optional().default(true),
        cookie: joi_1.default.object({
            domain: joi_1.default.string().optional(),
            transient: joi_1.default.boolean().optional().default(false),
            httpOnly: joi_1.default.boolean().optional().default(true),
            sameSite: joi_1.default.string().valid('lax', 'strict', 'none').optional().default('lax'),
            secure: joi_1.default.when(joi_1.default.ref('/baseURL'), {
                is: joi_1.default.string().pattern(isHttps),
                then: joi_1.default.boolean().valid(true).default(true).messages({
                    'any.only': 'Cookies must be secure when base url is https.'
                }),
                otherwise: joi_1.default.boolean().valid(false).default(false).messages({
                    'any.only': 'Cookies set with the `Secure` property wont be attached to http requests'
                })
            }),
            path: joi_1.default.string().uri({
                relativeOnly: true
            }).optional()
        }).default().unknown(false)
    }).default().unknown(false),
    auth0Logout: joi_1.default.boolean().optional(),
    authorizationParams: joi_1.default.object({
        response_type: joi_1.default.string().optional().valid('id_token', 'code id_token', 'code').default('id_token'),
        scope: joi_1.default.string().optional().pattern(/\bopenid\b/, 'contains openid').default('openid profile email'),
        response_mode: joi_1.default.string().optional().when('response_type', {
            is: 'code',
            then: joi_1.default.valid('query', 'form_post'),
            otherwise: joi_1.default.valid('form_post').default('form_post')
        })
    }).optional().unknown(true).default(),
    baseURL: joi_1.default.string().uri().required().when(joi_1.default.ref('authorizationParams.response_mode'), {
        is: 'form_post',
        then: joi_1.default.string().pattern(isHttps).rule({
            warn: true,
            message: "Using 'form_post' for response_mode may cause issues for you logging in over http, " + 'see https://github.com/auth0/express-openid-connect/blob/master/FAQ.md'
        })
    }),
    clientID: joi_1.default.string().required(),
    clientSecret: joi_1.default.string().when(joi_1.default.ref('clientAuthMethod', {
        adjust: (value)=>value && value.includes('client_secret')
    }), {
        is: true,
        then: joi_1.default.string().required().messages({
            'any.required': '"clientSecret" is required for the clientAuthMethod {{clientAuthMethod}}'
        })
    }).when(joi_1.default.ref('idTokenSigningAlg', {
        adjust: (value)=>value && value.startsWith('HS')
    }), {
        is: true,
        then: joi_1.default.string().required().messages({
            'any.required': '"clientSecret" is required for ID tokens with HMAC based algorithms'
        })
    }),
    clockTolerance: joi_1.default.number().optional().default(60),
    httpTimeout: joi_1.default.number().optional().default(5000),
    httpAgent: joi_1.default.object().optional(),
    enableTelemetry: joi_1.default.boolean().optional().default(true),
    getLoginState: joi_1.default.function().optional().default(()=>get_login_state_1.getLoginState),
    identityClaimFilter: joi_1.default.array().optional().default([
        'aud',
        'iss',
        'iat',
        'exp',
        'nbf',
        'nonce',
        'azp',
        'auth_time',
        's_hash',
        'at_hash',
        'c_hash'
    ]),
    idpLogout: joi_1.default.boolean().optional().default((parent)=>parent.auth0Logout || false),
    idTokenSigningAlg: joi_1.default.string().insensitive().not('none').optional().default('RS256'),
    issuerBaseURL: joi_1.default.string().uri().required(),
    legacySameSiteCookie: joi_1.default.boolean().optional().default(true),
    routes: joi_1.default.object({
        callback: joi_1.default.string().uri({
            relativeOnly: true
        }).required(),
        postLogoutRedirect: joi_1.default.string().uri({
            allowRelative: true
        }).default('')
    }).default().unknown(false),
    clientAuthMethod: joi_1.default.string().valid('client_secret_basic', 'client_secret_post', 'client_secret_jwt', 'private_key_jwt', 'none').optional().default((parent)=>{
        if (parent.authorizationParams.response_type === 'id_token' && !parent.pushedAuthorizationRequests) {
            return 'none';
        }
        if (parent.clientAssertionSigningKey) {
            return 'private_key_jwt';
        }
        return 'client_secret_basic';
    }).when(joi_1.default.ref('authorizationParams.response_type', {
        adjust: (value)=>value && value.includes('code')
    }), {
        is: true,
        then: joi_1.default.string().invalid('none').messages({
            'any.only': 'Public code flow clients are not supported.'
        })
    }).when(joi_1.default.ref('pushedAuthorizationRequests'), {
        is: true,
        then: joi_1.default.string().invalid('none').messages({
            'any.only': 'Public PAR clients are not supported'
        })
    }),
    clientAssertionSigningKey: joi_1.default.any().optional().when(joi_1.default.ref('clientAuthMethod'), {
        is: 'private_key_jwt',
        then: joi_1.default.any().required().messages({
            'any.required': '"clientAssertionSigningKey" is required for a "clientAuthMethod" of "private_key_jwt"'
        })
    }),
    clientAssertionSigningAlg: joi_1.default.string().optional().valid('RS256', 'RS384', 'RS512', 'PS256', 'PS384', 'PS512', 'ES256', 'ES256K', 'ES384', 'ES512', 'EdDSA'),
    transactionCookie: joi_1.default.object({
        name: joi_1.default.string().default('auth_verification'),
        domain: joi_1.default.string().default(joi_1.default.ref('/session.cookie.domain')),
        secure: joi_1.default.boolean().default(joi_1.default.ref('/session.cookie.secure')),
        sameSite: joi_1.default.string().valid('lax', 'strict', 'none').default(joi_1.default.ref('/session.cookie.sameSite')),
        path: joi_1.default.string().uri({
            relativeOnly: true
        }).default(joi_1.default.ref('/session.cookie.transient'))
    }).default().unknown(false),
    backchannelLogout: joi_1.default.alternatives([
        joi_1.default.object({
            store: joi_1.default.object().optional()
        }),
        joi_1.default.boolean()
    ]).default(false),
    pushedAuthorizationRequests: joi_1.default.boolean().optional().default(false)
});
const get = (params = {})=>{
    const { value, error, warning } = paramsSchema.validate(params, {
        allowUnknown: true
    });
    if (error) {
        throw new TypeError(error.details[0].message);
    }
    if (warning) {
        console.warn(warning.message);
    }
    return value;
};
exports.get = get; //# sourceMappingURL=get-config.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/utils/encoding.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.decodeState = exports.encodeState = void 0;
const tslib_1 = __turbopack_require__("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const jose = tslib_1.__importStar(__turbopack_require__("[project]/node_modules/jose/dist/node/cjs/index.js [app-route] (ecmascript)"));
/**
 * Prepare a state object to send.
 *
 * @param {object} stateObject
 *
 * @return {string}
 */ function encodeState(stateObject) {
    // This filters out nonce, code_verifier, and max_age from the state object so that the values are
    // only stored in its dedicated transient cookie.
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { nonce, code_verifier, max_age } = stateObject, filteredState = tslib_1.__rest(stateObject, [
        "nonce",
        "code_verifier",
        "max_age"
    ]);
    return jose.base64url.encode(JSON.stringify(filteredState));
}
exports.encodeState = encodeState;
/**
 * Decode a state value.
 *
 * @param {string} stateValue
 *
 * @return {object|undefined}
 */ function decodeState(stateValue) {
    try {
        return JSON.parse(new TextDecoder().decode(jose.base64url.decode(stateValue)));
    } catch (e) {
        return undefined;
    }
}
exports.decodeState = decodeState; //# sourceMappingURL=encoding.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/handlers/login.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const tslib_1 = __turbopack_require__("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const url_join_1 = tslib_1.__importDefault(__turbopack_require__("[project]/node_modules/url-join/lib/url-join.js [app-route] (ecmascript)"));
const encoding_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/utils/encoding.js [app-route] (ecmascript)");
const debug_1 = tslib_1.__importDefault(__turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/utils/debug.js [app-route] (ecmascript)"));
const debug = (0, debug_1.default)('handlers');
function getRedirectUri(config) {
    return (0, url_join_1.default)(config.baseURL, config.routes.callback);
}
function loginHandlerFactory(getConfig, getClient, transientHandler) {
    const getConfigFn = typeof getConfig === 'function' ? getConfig : ()=>getConfig;
    return async (req, res, options = {})=>{
        const config = await getConfigFn(req);
        const client = await getClient(config);
        const returnTo = options.returnTo || config.baseURL;
        const opts = Object.assign({
            returnTo,
            getLoginState: config.getLoginState
        }, options);
        // Ensure a redirect_uri, merge in configuration options, then passed-in options.
        opts.authorizationParams = Object.assign(Object.assign({
            redirect_uri: getRedirectUri(config)
        }, config.authorizationParams), opts.authorizationParams || {});
        const stateValue = await opts.getLoginState(opts);
        if (typeof stateValue !== 'object') {
            throw new Error('Custom state value must be an object.');
        }
        stateValue.nonce = client.generateRandomNonce();
        stateValue.returnTo = stateValue.returnTo || opts.returnTo;
        const responseType = opts.authorizationParams.response_type;
        const usePKCE = responseType.includes('code');
        if (usePKCE) {
            debug('response_type includes code, the authorization request will use PKCE');
            stateValue.code_verifier = client.generateRandomCodeVerifier();
        }
        const validResponseTypes = [
            'id_token',
            'code id_token',
            'code'
        ];
        if (!validResponseTypes.includes(responseType)) {
            throw new Error(`response_type should be one of ${validResponseTypes.join(', ')}`);
        }
        if (!/\bopenid\b/.test(opts.authorizationParams.scope)) {
            throw new Error('scope should contain "openid"');
        }
        const authVerification = {
            nonce: client.generateRandomNonce(),
            state: (0, encoding_1.encodeState)(stateValue)
        };
        if (opts.authorizationParams.max_age) {
            authVerification.max_age = opts.authorizationParams.max_age;
        }
        const authParams = Object.assign(Object.assign({}, opts.authorizationParams), authVerification);
        if (usePKCE) {
            authVerification.code_verifier = client.generateRandomCodeVerifier();
            authParams.code_challenge_method = 'S256';
            authParams.code_challenge = await client.calculateCodeChallenge(authVerification.code_verifier);
        }
        if (responseType !== config.authorizationParams.response_type) {
            authVerification.response_type = responseType;
        }
        await transientHandler.save(config.transactionCookie.name, req, res, {
            sameSite: authParams.response_mode === 'form_post' ? 'none' : config.transactionCookie.sameSite,
            value: JSON.stringify(authVerification)
        });
        const authorizationUrl = await client.authorizationUrl(authParams);
        debug('redirecting to %s', authorizationUrl);
        res.redirect(authorizationUrl);
    };
}
exports.default = loginHandlerFactory; //# sourceMappingURL=login.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/handlers/logout.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const tslib_1 = __turbopack_require__("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const url_join_1 = tslib_1.__importDefault(__turbopack_require__("[project]/node_modules/url-join/lib/url-join.js [app-route] (ecmascript)"));
const debug_1 = tslib_1.__importDefault(__turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/utils/debug.js [app-route] (ecmascript)"));
const debug = (0, debug_1.default)('logout');
function logoutHandlerFactory(getConfig, getClient, sessionCache) {
    const getConfigFn = typeof getConfig === 'function' ? getConfig : ()=>getConfig;
    return async (req, res, options = {})=>{
        const config = await getConfigFn(req);
        const client = await getClient(config);
        let returnURL = options.returnTo || config.routes.postLogoutRedirect;
        debug('logout() with return url: %s', returnURL);
        try {
            new URL(returnURL);
        } catch (_) {
            returnURL = (0, url_join_1.default)(config.baseURL, returnURL);
        }
        const isAuthenticated = await sessionCache.isAuthenticated(req.req, res.res);
        if (!isAuthenticated) {
            debug('end-user already logged out, redirecting to %s', returnURL);
            res.redirect(returnURL);
            return;
        }
        const idToken = await sessionCache.getIdToken(req.req, res.res);
        await sessionCache.delete(req.req, res.res);
        if (!config.idpLogout) {
            debug('performing a local only logout, redirecting to %s', returnURL);
            res.redirect(returnURL);
            return;
        }
        returnURL = await client.endSessionUrl(Object.assign(Object.assign({}, options.logoutParams), {
            post_logout_redirect_uri: returnURL,
            id_token_hint: idToken
        }));
        debug('logging out of identity provider, redirecting to %s', returnURL);
        res.redirect(returnURL);
    };
}
exports.default = logoutHandlerFactory; //# sourceMappingURL=logout.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/handlers/callback.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const tslib_1 = __turbopack_require__("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const url_join_1 = tslib_1.__importDefault(__turbopack_require__("[project]/node_modules/url-join/lib/url-join.js [app-route] (ecmascript)"));
const encoding_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/utils/encoding.js [app-route] (ecmascript)");
const errors_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/utils/errors.js [app-route] (ecmascript)");
function getRedirectUri(config) {
    return (0, url_join_1.default)(config.baseURL, config.routes.callback);
}
function callbackHandlerFactory(getConfig, getClient, sessionCache, transientCookieHandler) {
    const getConfigFn = typeof getConfig === 'function' ? getConfig : ()=>getConfig;
    return async (req, res, options)=>{
        const config = await getConfigFn(req);
        const client = await getClient(config);
        const redirectUri = (options === null || options === void 0 ? void 0 : options.redirectUri) || getRedirectUri(config);
        let tokenResponse;
        let authVerification;
        const cookie = await transientCookieHandler.read(config.transactionCookie.name, req, res);
        if (!cookie) {
            throw new errors_1.MissingStateCookieError();
        }
        try {
            authVerification = JSON.parse(cookie);
        } catch (_) {
            throw new errors_1.MalformedStateCookieError();
        }
        const { max_age, code_verifier, nonce, state: expectedState, response_type = config.authorizationParams.response_type } = authVerification;
        let callbackParams;
        try {
            callbackParams = await client.callbackParams(req, expectedState);
        } catch (err) {
            err.status = 400;
            err.statusCode = 400;
            err.openIdState = (0, encoding_1.decodeState)(expectedState);
            throw err;
        }
        if (!callbackParams.get('state')) {
            throw new errors_1.MissingStateParamError();
        }
        try {
            tokenResponse = await client.callback(redirectUri, callbackParams, {
                max_age: max_age !== undefined ? +max_age : undefined,
                code_verifier,
                nonce,
                state: expectedState,
                response_type
            }, {
                exchangeBody: options === null || options === void 0 ? void 0 : options.authorizationParams
            });
        } catch (err) {
            err.status = 400;
            err.statusCode = 400;
            err.openIdState = (0, encoding_1.decodeState)(expectedState);
            throw err;
        }
        const openidState = (0, encoding_1.decodeState)(expectedState);
        let session = await sessionCache.fromTokenEndpointResponse(req, res, tokenResponse);
        if (options === null || options === void 0 ? void 0 : options.afterCallback) {
            session = await options.afterCallback(session, openidState);
        }
        if (session) {
            await sessionCache.create(req.req, res.res, session);
        }
        res.redirect(openidState.returnTo || config.baseURL);
    };
}
exports.default = callbackHandlerFactory; //# sourceMappingURL=callback.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/utils/logout-token-verifier.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const jose_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/index.js [app-route] (ecmascript)");
function getLogoutTokenVerifier() {
    let remoteJwkSet;
    return async (logoutToken, config, issuerMetadata)=>{
        let keyInput;
        if (config.idTokenSigningAlg === 'RS256') {
            if (!remoteJwkSet) {
                remoteJwkSet = (0, jose_1.createRemoteJWKSet)(new URL(issuerMetadata.jwks_uri));
            }
            keyInput = remoteJwkSet;
        } else {
            keyInput = new TextEncoder().encode(config.clientSecret);
        }
        const { payload } = await (0, jose_1.jwtVerify)(logoutToken, keyInput, {
            issuer: issuerMetadata.issuer,
            audience: config.clientID,
            algorithms: [
                config.idTokenSigningAlg
            ],
            requiredClaims: [
                'iat'
            ]
        });
        if (!('sid' in payload) && !('sub' in payload)) {
            throw new Error('either "sid" or "sub" (or both) claims must be present');
        }
        if ('nonce' in payload) {
            throw new Error('"nonce" claim is prohibited');
        }
        if (!('events' in payload)) {
            throw new Error('"events" claim is missing');
        }
        if (typeof payload.events !== 'object' || payload.events === null) {
            throw new Error('"events" claim must be an object');
        }
        if (!('http://schemas.openid.net/event/backchannel-logout' in payload.events)) {
            throw new Error('"http://schemas.openid.net/event/backchannel-logout" member is missing in the "events" claim');
        }
        if (typeof payload.events['http://schemas.openid.net/event/backchannel-logout'] !== 'object') {
            throw new Error('"http://schemas.openid.net/event/backchannel-logout" member in the "events" claim must be an object');
        }
        return payload;
    };
}
exports.default = getLogoutTokenVerifier; //# sourceMappingURL=logout-token-verifier.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/handlers/backchannel-logout.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.deleteSub = exports.isLoggedOut = void 0;
const tslib_1 = __turbopack_require__("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const logout_token_verifier_1 = tslib_1.__importDefault(__turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/utils/logout-token-verifier.js [app-route] (ecmascript)"));
const errors_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/utils/errors.js [app-route] (ecmascript)");
const getStore = (config)=>{
    const { session: { store }, backchannelLogout } = config;
    return typeof backchannelLogout === 'boolean' ? store : backchannelLogout.store;
};
function backchannelLogoutHandlerFactory(getConfig, getClient) {
    const getConfigFn = typeof getConfig === 'function' ? getConfig : ()=>getConfig;
    const verifyLogoutToken = (0, logout_token_verifier_1.default)();
    return async (req, res)=>{
        const config = await getConfigFn(req);
        const client = await getClient(config);
        res.setHeader('cache-control', 'no-store');
        const body = new URLSearchParams(await req.getBody());
        const logoutToken = body.get('logout_token');
        if (!logoutToken) {
            throw new errors_1.BackchannelLogoutError('invalid_request', 'Missing Logout Token');
        }
        let token;
        try {
            token = await verifyLogoutToken(logoutToken, config, await client.getIssuerMetadata());
        } catch (e) {
            throw new errors_1.BackchannelLogoutError('invalid_request', e.message);
        }
        const { clientID, session: { absoluteDuration, rolling: rollingEnabled, rollingDuration } } = config;
        const store = getStore(config);
        const maxAge = (rollingEnabled ? Math.min(absoluteDuration, rollingDuration) : absoluteDuration) * 1000;
        const now = Date.now() / 1000 | 0;
        const payload = {
            header: {
                iat: now,
                uat: now,
                exp: now + maxAge,
                maxAge
            },
            data: {}
        };
        try {
            const { sid, sub } = token;
            await Promise.all([
                sid && store.set(`sid|${clientID}|${sid}`, payload),
                sub && store.set(`sub|${clientID}|${sub}`, payload)
            ]);
        } catch (e) {
            throw new errors_1.BackchannelLogoutError('application_error', e.message);
        }
        res.send204();
    };
}
exports.default = backchannelLogoutHandlerFactory;
const isLoggedOut = async (user, config)=>{
    const { clientID } = config;
    const store = getStore(config);
    const { sid, sub } = user;
    const [logoutSid, logoutSub] = await Promise.all([
        store.get(`sid|${clientID}|${sid}`),
        store.get(`sub|${clientID}|${sub}`)
    ]);
    return !!(logoutSid || logoutSub);
};
exports.isLoggedOut = isLoggedOut;
const deleteSub = async (sub, config)=>{
    const { clientID } = config;
    const store = getStore(config);
    await store.delete(`sub|${clientID}|${sub}`);
};
exports.deleteSub = deleteSub; //# sourceMappingURL=backchannel-logout.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/client/abstract-client.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AbstractClient = void 0;
class AbstractClient {
    constructor(config, telemetry){
        this.config = config;
        this.telemetry = telemetry;
    }
}
exports.AbstractClient = AbstractClient; //# sourceMappingURL=abstract-client.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AbstractClient = exports.deleteSub = exports.isLoggedOut = exports.backchannelLogoutHandler = exports.callbackHandler = exports.logoutHandler = exports.loginHandler = exports.getConfig = exports.TransientStore = exports.StatefulSession = exports.AbstractSession = exports.StatelessSession = exports.ApplicationError = exports.IdentityProviderError = exports.MalformedStateCookieError = exports.MissingStateCookieError = exports.MissingStateParamError = void 0;
var errors_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/utils/errors.js [app-route] (ecmascript)");
Object.defineProperty(exports, "MissingStateParamError", {
    enumerable: true,
    get: function() {
        return errors_1.MissingStateParamError;
    }
});
Object.defineProperty(exports, "MissingStateCookieError", {
    enumerable: true,
    get: function() {
        return errors_1.MissingStateCookieError;
    }
});
Object.defineProperty(exports, "MalformedStateCookieError", {
    enumerable: true,
    get: function() {
        return errors_1.MalformedStateCookieError;
    }
});
Object.defineProperty(exports, "IdentityProviderError", {
    enumerable: true,
    get: function() {
        return errors_1.IdentityProviderError;
    }
});
Object.defineProperty(exports, "ApplicationError", {
    enumerable: true,
    get: function() {
        return errors_1.ApplicationError;
    }
});
var stateless_session_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/session/stateless-session.js [app-route] (ecmascript)");
Object.defineProperty(exports, "StatelessSession", {
    enumerable: true,
    get: function() {
        return stateless_session_1.StatelessSession;
    }
});
var abstract_session_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/session/abstract-session.js [app-route] (ecmascript)");
Object.defineProperty(exports, "AbstractSession", {
    enumerable: true,
    get: function() {
        return abstract_session_1.AbstractSession;
    }
});
var stateful_session_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/session/stateful-session.js [app-route] (ecmascript)");
Object.defineProperty(exports, "StatefulSession", {
    enumerable: true,
    get: function() {
        return stateful_session_1.StatefulSession;
    }
});
var transient_store_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/transient-store.js [app-route] (ecmascript)");
Object.defineProperty(exports, "TransientStore", {
    enumerable: true,
    get: function() {
        return __importDefault(transient_store_1).default;
    }
});
var get_config_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/get-config.js [app-route] (ecmascript)");
Object.defineProperty(exports, "getConfig", {
    enumerable: true,
    get: function() {
        return get_config_1.get;
    }
});
var login_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/handlers/login.js [app-route] (ecmascript)");
Object.defineProperty(exports, "loginHandler", {
    enumerable: true,
    get: function() {
        return __importDefault(login_1).default;
    }
});
var logout_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/handlers/logout.js [app-route] (ecmascript)");
Object.defineProperty(exports, "logoutHandler", {
    enumerable: true,
    get: function() {
        return __importDefault(logout_1).default;
    }
});
var callback_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/handlers/callback.js [app-route] (ecmascript)");
Object.defineProperty(exports, "callbackHandler", {
    enumerable: true,
    get: function() {
        return __importDefault(callback_1).default;
    }
});
var backchannel_logout_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/handlers/backchannel-logout.js [app-route] (ecmascript)");
Object.defineProperty(exports, "backchannelLogoutHandler", {
    enumerable: true,
    get: function() {
        return __importDefault(backchannel_logout_1).default;
    }
});
Object.defineProperty(exports, "isLoggedOut", {
    enumerable: true,
    get: function() {
        return backchannel_logout_1.isLoggedOut;
    }
});
Object.defineProperty(exports, "deleteSub", {
    enumerable: true,
    get: function() {
        return backchannel_logout_1.deleteSub;
    }
});
var abstract_client_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/client/abstract-client.js [app-route] (ecmascript)");
Object.defineProperty(exports, "AbstractClient", {
    enumerable: true,
    get: function() {
        return abstract_client_1.AbstractClient;
    }
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/http/auth0-request-cookies.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
class Auth0RequestCookies {
}
exports.default = Auth0RequestCookies; //# sourceMappingURL=auth0-request-cookies.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/http/auth0-request.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const tslib_1 = __turbopack_require__("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const auth0_request_cookies_1 = tslib_1.__importDefault(__turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/http/auth0-request-cookies.js [app-route] (ecmascript)"));
class Auth0Request extends auth0_request_cookies_1.default {
    constructor(req){
        super();
        this.req = req;
    }
}
exports.default = Auth0Request; //# sourceMappingURL=auth0-request.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/http/auth0-response-cookies.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
class Auth0ResponseCookies {
    clearCookie(name, options = {}) {
        const { domain, path, secure, sameSite } = options;
        const clearOptions = {
            domain,
            path,
            maxAge: 0
        };
        // If SameSite=None is set, the cookie Secure attribute must also be set (or the cookie will be blocked)
        // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite#none
        if (sameSite === 'none') {
            clearOptions.secure = secure;
            clearOptions.sameSite = sameSite;
        }
        this.setCookie(name, '', clearOptions);
    }
}
exports.default = Auth0ResponseCookies; //# sourceMappingURL=auth0-response-cookies.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/http/auth0-response.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const tslib_1 = __turbopack_require__("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const auth0_response_cookies_1 = tslib_1.__importDefault(__turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/http/auth0-response-cookies.js [app-route] (ecmascript)"));
class Auth0Response extends auth0_response_cookies_1.default {
    constructor(res){
        super();
        this.res = res;
    }
}
exports.default = Auth0Response; //# sourceMappingURL=auth0-response.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/http/node-request.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const tslib_1 = __turbopack_require__("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const cookie_1 = __turbopack_require__("[project]/node_modules/cookie/index.js [app-route] (ecmascript)");
const auth0_request_1 = tslib_1.__importDefault(__turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/http/auth0-request.js [app-route] (ecmascript)"));
class NodeRequest extends auth0_request_1.default {
    constructor(req){
        /* c8 ignore next */ super(req);
        this.req = req;
    }
    getUrl() {
        return this.req.url;
    }
    getMethod() {
        return this.req.method;
    }
    getBody() {
        return this.req.body;
    }
    getCookies() {
        return (0, cookie_1.parse)(this.req.headers.cookie || '');
    }
}
exports.default = NodeRequest; //# sourceMappingURL=node-request.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/http/node-response.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const tslib_1 = __turbopack_require__("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const cookie_1 = __turbopack_require__("[project]/node_modules/cookie/index.js [app-route] (ecmascript)");
const auth0_response_1 = tslib_1.__importDefault(__turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/http/auth0-response.js [app-route] (ecmascript)"));
const errors_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/utils/errors.js [app-route] (ecmascript)");
class NodeResponse extends auth0_response_1.default {
    constructor(res){
        /* c8 ignore next */ super(res);
        this.res = res;
    }
    setCookie(name, value, options) {
        let cookies = this.res.getHeader('Set-Cookie') || [];
        if (!Array.isArray(cookies)) {
            cookies = [
                cookies
            ];
        }
        this.res.setHeader('Set-Cookie', [
            ...cookies.filter((cookie)=>!cookie.startsWith(`${name}=`)),
            (0, cookie_1.serialize)(name, value, options)
        ]);
    }
    redirect(location, status = 302) {
        if (this.res.writableEnded) {
            return;
        }
        this.res.writeHead(status, {
            Location: this.res.getHeader('Location') || location
        });
        this.res.end((0, errors_1.htmlSafe)(location));
    }
    send204() {
        this.res.statusCode = 204;
        this.res.end();
    }
    setHeader(name, value) {
        this.res.setHeader(name, value);
    }
}
exports.default = NodeResponse; //# sourceMappingURL=node-response.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/http/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NodeResponse = exports.NodeRequest = exports.Auth0ResponseCookies = exports.Auth0RequestCookies = exports.Auth0Response = exports.Auth0Request = void 0;
var auth0_request_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/http/auth0-request.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Auth0Request", {
    enumerable: true,
    get: function() {
        return __importDefault(auth0_request_1).default;
    }
});
var auth0_response_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/http/auth0-response.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Auth0Response", {
    enumerable: true,
    get: function() {
        return __importDefault(auth0_response_1).default;
    }
});
var auth0_request_cookies_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/http/auth0-request-cookies.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Auth0RequestCookies", {
    enumerable: true,
    get: function() {
        return __importDefault(auth0_request_cookies_1).default;
    }
});
var auth0_response_cookies_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/http/auth0-response-cookies.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Auth0ResponseCookies", {
    enumerable: true,
    get: function() {
        return __importDefault(auth0_response_cookies_1).default;
    }
});
var node_request_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/http/node-request.js [app-route] (ecmascript)");
Object.defineProperty(exports, "NodeRequest", {
    enumerable: true,
    get: function() {
        return __importDefault(node_request_1).default;
    }
});
var node_response_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/http/node-response.js [app-route] (ecmascript)");
Object.defineProperty(exports, "NodeResponse", {
    enumerable: true,
    get: function() {
        return __importDefault(node_response_1).default;
    }
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/http/auth0-next-api-request.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const http_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/http/index.js [app-route] (ecmascript)");
class Auth0NextApiRequest extends http_1.Auth0Request {
    constructor(req){
        /* c8 ignore next */ super(req);
    }
    getUrl() {
        return this.req.url;
    }
    getMethod() {
        return this.req.method;
    }
    getBody() {
        return this.req.body;
    }
    getCookies() {
        return this.req.cookies;
    }
}
exports.default = Auth0NextApiRequest; //# sourceMappingURL=auth0-next-api-request.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/http/auth0-next-api-response.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const http_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/http/index.js [app-route] (ecmascript)");
class Auth0NextApiResponse extends http_1.NodeResponse {
    redirect(location, status = 302) {
        if (this.res.writableEnded) {
            return;
        }
        this.res.redirect(status, this.res.getHeader('Location') || location);
    }
}
exports.default = Auth0NextApiResponse; //# sourceMappingURL=auth0-next-api-response.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/http/auth0-next-request.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const http_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/http/index.js [app-route] (ecmascript)");
class Auth0NextRequest extends http_1.Auth0Request {
    constructor(req){
        /* c8 ignore next */ super(req);
    }
    getUrl() {
        return this.req.url;
    }
    getMethod() {
        return this.req.method;
    }
    async getBody() {
        return this.req.text();
    }
    getCookies() {
        const { cookies } = this.req;
        if (typeof cookies.getAll === 'function') {
            return this.req.cookies.getAll().reduce((memo, { name, value })=>Object.assign(Object.assign({}, memo), {
                    [name]: value
                }), {});
        }
        // Edge cookies before Next 13.0.1 have no `getAll` and extend `Map`.
        const legacyCookies = cookies;
        return Array.from(legacyCookies.keys()).reduce((memo, key)=>{
            memo[key] = legacyCookies.get(key);
            return memo;
        }, {});
    }
}
exports.default = Auth0NextRequest; //# sourceMappingURL=auth0-next-request.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/http/auth0-next-response.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const server_1 = __turbopack_require__("[project]/node_modules/next/server.js [app-route] (ecmascript)");
const http_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/http/index.js [app-route] (ecmascript)");
class Auth0NextResponse extends http_1.Auth0Response {
    constructor(res){
        /* c8 ignore next */ super(res);
    }
    setCookie(name, value, options) {
        this.res.cookies.set(name, value, options);
    }
    clearCookie(name, options) {
        this.setCookie(name, '', Object.assign(Object.assign({}, options), {
            expires: new Date(0)
        }));
    }
    redirect(location, status = 302) {
        const oldRes = this.res;
        this.res = new server_1.NextResponse(null, {
            status
        });
        oldRes.headers.forEach((value, key)=>{
            this.res.headers.set(key, value);
        });
        this.res.headers.set('location', location);
        for (const cookie of oldRes.cookies.getAll()){
            this.res.cookies.set(cookie);
        }
    }
    setHeader(name, value) {
        this.res.headers.set(name, value);
    }
    send204() {
        const oldRes = this.res;
        this.res = new server_1.NextResponse(null, {
            status: 204
        });
        oldRes.headers.forEach((value, key)=>{
            this.res.headers.set(key, value);
        });
    }
}
exports.default = Auth0NextResponse; //# sourceMappingURL=auth0-next-response.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/http/auth0-next-request-cookies.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const http_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/http/index.js [app-route] (ecmascript)");
class Auth0NextRequestCookies extends http_1.Auth0RequestCookies {
    constructor(){
        super();
    }
    getCookies() {
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        const { cookies } = __turbopack_require__("[project]/node_modules/next/headers.js [app-route] (ecmascript)");
        const cookieStore = cookies();
        return cookieStore.getAll().reduce((memo, { name, value })=>Object.assign(Object.assign({}, memo), {
                [name]: value
            }), {});
    }
}
exports.default = Auth0NextRequestCookies; //# sourceMappingURL=auth0-next-request-cookies.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/http/auth0-next-response-cookies.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const http_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/http/index.js [app-route] (ecmascript)");
let warned = false;
const warn = ()=>{
    /* c8 ignore next 8 */ if (("TURBOPACK compile-time value", "development") === 'development' && !warned) {
        console.warn('nextjs-auth0 is attempting to set cookies from a server component,' + 'see https://github.com/auth0/nextjs-auth0#using-this-sdk-with-react-server-components');
        warned = true;
    }
};
class Auth0NextResponseCookies extends http_1.Auth0ResponseCookies {
    constructor(){
        super();
    }
    setCookie(name, value, options) {
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        const { cookies } = __turbopack_require__("[project]/node_modules/next/headers.js [app-route] (ecmascript)");
        const cookieSetter = cookies();
        try {
            cookieSetter.set(Object.assign(Object.assign({}, options), {
                name,
                value
            }));
        } catch (_) {
            warn();
        }
    }
    clearCookie(name, options) {
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        const { cookies } = __turbopack_require__("[project]/node_modules/next/headers.js [app-route] (ecmascript)");
        const cookieSetter = cookies();
        try {
            cookieSetter.set(Object.assign(Object.assign({}, options), {
                name,
                value: '',
                expires: new Date(0)
            }));
        } catch (_) {
            warn();
        }
    }
}
exports.default = Auth0NextResponseCookies; //# sourceMappingURL=auth0-next-response-cookies.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/http/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Auth0NextResponseCookies = exports.Auth0NextRequestCookies = exports.Auth0NextResponse = exports.Auth0NextRequest = exports.Auth0NextApiResponse = exports.Auth0NextApiRequest = void 0;
var auth0_next_api_request_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/http/auth0-next-api-request.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Auth0NextApiRequest", {
    enumerable: true,
    get: function() {
        return __importDefault(auth0_next_api_request_1).default;
    }
});
var auth0_next_api_response_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/http/auth0-next-api-response.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Auth0NextApiResponse", {
    enumerable: true,
    get: function() {
        return __importDefault(auth0_next_api_response_1).default;
    }
});
var auth0_next_request_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/http/auth0-next-request.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Auth0NextRequest", {
    enumerable: true,
    get: function() {
        return __importDefault(auth0_next_request_1).default;
    }
});
var auth0_next_response_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/http/auth0-next-response.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Auth0NextResponse", {
    enumerable: true,
    get: function() {
        return __importDefault(auth0_next_response_1).default;
    }
});
var auth0_next_request_cookies_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/http/auth0-next-request-cookies.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Auth0NextRequestCookies", {
    enumerable: true,
    get: function() {
        return __importDefault(auth0_next_request_cookies_1).default;
    }
});
var auth0_next_response_cookies_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/http/auth0-next-response-cookies.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Auth0NextResponseCookies", {
    enumerable: true,
    get: function() {
        return __importDefault(auth0_next_response_cookies_1).default;
    }
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/utils/req-helpers.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isNextApiRequest = exports.isRequest = void 0;
const isRequest = (req)=>{
    return req instanceof Request || req.headers instanceof Headers || typeof req.bodyUsed === 'boolean';
};
exports.isRequest = isRequest;
const isNextApiRequest = (req)=>{
    return !(0, exports.isRequest)(req) && 'query' in req;
};
exports.isNextApiRequest = isNextApiRequest; //# sourceMappingURL=req-helpers.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/session/cache.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.set = exports.get = exports.getAuth0ReqRes = void 0;
const auth0_session_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/index.js [app-route] (ecmascript)");
const session_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/session/session.js [app-route] (ecmascript)");
const http_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/http/index.js [app-route] (ecmascript)");
const http_2 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/http/index.js [app-route] (ecmascript)");
const req_helpers_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/utils/req-helpers.js [app-route] (ecmascript)");
const getAuth0ReqRes = (req, res)=>{
    if ((0, req_helpers_1.isRequest)(req)) {
        return [
            new http_2.Auth0NextRequest(req),
            new http_2.Auth0NextResponse(res)
        ];
    }
    if ((0, req_helpers_1.isNextApiRequest)(req)) {
        return [
            new http_2.Auth0NextApiRequest(req),
            new http_2.Auth0NextApiResponse(res)
        ];
    }
    return [
        new http_1.NodeRequest(req),
        new http_1.NodeResponse(res)
    ];
};
exports.getAuth0ReqRes = getAuth0ReqRes;
class SessionCache {
    constructor(getConfig){
        this.getConfig = getConfig;
        this.cache = new WeakMap();
        this.iatCache = new WeakMap();
    }
    getSessionStore(config) {
        if (!this.sessionStore) {
            this.sessionStore = config.session.store ? new auth0_session_1.StatefulSession(config) : new auth0_session_1.StatelessSession(config);
        }
        return this.sessionStore;
    }
    async init(req, res, autoSave = true) {
        if (!this.cache.has(req)) {
            const [auth0Req] = (0, exports.getAuth0ReqRes)(req, res);
            const config = await this.getConfig(auth0Req);
            const sessionStore = this.getSessionStore(config);
            const [json, iat] = await sessionStore.read(auth0Req);
            const session = (0, session_1.fromJson)(json);
            if (session && config.backchannelLogout && await (0, auth0_session_1.isLoggedOut)(session.user, config)) {
                this.cache.set(req, null);
                await this.save(req, res);
            } else {
                this.iatCache.set(req, iat);
                this.cache.set(req, session);
                if (config.session.rolling && config.session.autoSave && autoSave) {
                    await this.save(req, res);
                }
            }
        }
    }
    async save(req, res) {
        const [auth0Req, auth0Res] = (0, exports.getAuth0ReqRes)(req, res);
        const config = await this.getConfig(auth0Req);
        const sessionStore = this.getSessionStore(config);
        await sessionStore.save(auth0Req, auth0Res, this.cache.get(req), this.iatCache.get(req));
    }
    async create(req, res, session) {
        const [auth0Req] = (0, exports.getAuth0ReqRes)(req, res);
        const config = await this.getConfig(auth0Req);
        if (config.backchannelLogout) {
            await (0, auth0_session_1.deleteSub)(session.user.sub, config);
        }
        this.cache.set(req, session);
        await this.save(req, res);
    }
    async delete(req, res) {
        await this.init(req, res, false);
        this.cache.set(req, null);
        await this.save(req, res);
    }
    async isAuthenticated(req, res) {
        await this.init(req, res);
        const session = this.cache.get(req);
        return !!(session === null || session === void 0 ? void 0 : session.user);
    }
    async getIdToken(req, res) {
        await this.init(req, res);
        const session = this.cache.get(req);
        return session === null || session === void 0 ? void 0 : session.idToken;
    }
    async set(req, res, session) {
        await this.init(req, res, false);
        this.cache.set(req, session);
        await this.save(req, res);
    }
    async get(req, res) {
        await this.init(req, res);
        return this.cache.get(req);
    }
    async fromTokenEndpointResponse(req, res, tokenSet) {
        const [auth0Req] = (0, exports.getAuth0ReqRes)(req, res);
        const config = await this.getConfig(auth0Req);
        return (0, session_1.fromTokenEndpointResponse)(tokenSet, config);
    }
}
exports.default = SessionCache;
const get = async ({ sessionCache, req, res })=>{
    if (req && res) {
        return [
            await sessionCache.get(req, res)
        ];
    }
    const auth0Req = new http_2.Auth0NextRequestCookies();
    const config = await sessionCache.getConfig(auth0Req);
    const sessionStore = sessionCache.getSessionStore(config);
    const { session: { rolling, autoSave } } = config;
    const [json, iat] = await sessionStore.read(auth0Req);
    const session = (0, session_1.fromJson)(json);
    if (session && config.backchannelLogout && await (0, auth0_session_1.isLoggedOut)(session.user, config)) {
        await (0, exports.set)({
            session: null,
            sessionCache
        });
        return [];
    } else {
        if (rolling && autoSave) {
            await (0, exports.set)({
                session,
                sessionCache,
                iat
            });
        }
        return [
            session,
            iat
        ];
    }
};
exports.get = get;
const set = async ({ session, sessionCache, iat, req, res })=>{
    if (req && res) {
        return sessionCache.set(req, res, session);
    }
    const auth0Req = new http_2.Auth0NextRequestCookies();
    const config = await sessionCache.getConfig(auth0Req);
    const sessionStore = sessionCache.getSessionStore(config);
    await sessionStore.save(auth0Req, new http_2.Auth0NextResponseCookies(), session, iat);
};
exports.set = set; //# sourceMappingURL=cache.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/session/get-access-token.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const errors_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/utils/errors.js [app-route] (ecmascript)");
const array_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/utils/array.js [app-route] (ecmascript)");
const session_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/session/index.js [app-route] (ecmascript)");
const cache_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/session/cache.js [app-route] (ecmascript)");
const http_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/http/index.js [app-route] (ecmascript)");
/**
 * @ignore
 */ function accessTokenFactory(getConfig, getClient, sessionCache) {
    return async (reqOrOpts, res, accessTokenRequest)=>{
        const options = res ? accessTokenRequest : reqOrOpts;
        const req = res ? reqOrOpts : undefined;
        const config = await getConfig(req ? (0, cache_1.getAuth0ReqRes)(req, res)[0] : new http_1.Auth0NextRequestCookies());
        const client = await getClient(config);
        const parts = await (0, session_1.get)({
            sessionCache,
            req,
            res
        });
        let [session] = parts;
        const [, iat] = parts;
        if (!session) {
            throw new errors_1.AccessTokenError(errors_1.AccessTokenErrorCode.MISSING_SESSION, 'The user does not have a valid session.');
        }
        if (!session.accessToken && !session.refreshToken) {
            throw new errors_1.AccessTokenError(errors_1.AccessTokenErrorCode.MISSING_ACCESS_TOKEN, 'The user does not have a valid access token.');
        }
        if (!session.accessTokenExpiresAt) {
            throw new errors_1.AccessTokenError(errors_1.AccessTokenErrorCode.EXPIRED_ACCESS_TOKEN, 'Expiration information for the access token is not available. The user will need to sign in again.');
        }
        if (options && options.scopes) {
            const persistedScopes = session.accessTokenScope;
            if (!persistedScopes || persistedScopes.length === 0) {
                throw new errors_1.AccessTokenError(errors_1.AccessTokenErrorCode.INSUFFICIENT_SCOPE, 'An access token with the requested scopes could not be provided. The user will need to sign in again.');
            }
            const matchingScopes = (0, array_1.intersect)(options.scopes, persistedScopes.split(' '));
            if (!(0, array_1.match)(options.scopes, [
                ...matchingScopes
            ])) {
                throw new errors_1.AccessTokenError(errors_1.AccessTokenErrorCode.INSUFFICIENT_SCOPE, `Could not retrieve an access token with scopes "${options.scopes.join(' ')}". The user will need to sign in again.`);
            }
        }
        // Check if the token has expired.
        // There is an edge case where we might have some clock skew where our code assumes the token is still valid.
        // Adding a skew of 1 minute to compensate.
        if (!session.refreshToken && session.accessTokenExpiresAt * 1000 - 60000 < Date.now()) {
            throw new errors_1.AccessTokenError(errors_1.AccessTokenErrorCode.EXPIRED_ACCESS_TOKEN, 'The access token expired and a refresh token is not available. The user will need to sign in again.');
        }
        if ((options === null || options === void 0 ? void 0 : options.refresh) && !session.refreshToken) {
            throw new errors_1.AccessTokenError(errors_1.AccessTokenErrorCode.MISSING_REFRESH_TOKEN, 'A refresh token is required to refresh the access token, but none is present.');
        }
        // Check if the token has expired.
        // There is an edge case where we might have some clock skew where our code assumes the token is still valid.
        // Adding a skew of 1 minute to compensate.
        if (session.refreshToken && session.accessTokenExpiresAt * 1000 - 60000 < Date.now() || session.refreshToken && options && options.refresh) {
            const tokenSet = await client.refresh(session.refreshToken, {
                exchangeBody: options === null || options === void 0 ? void 0 : options.authorizationParams
            });
            // Update the session.
            const newSession = (0, session_1.fromTokenEndpointResponse)(tokenSet, config);
            Object.assign(session, Object.assign(Object.assign({}, newSession), {
                refreshToken: newSession.refreshToken || session.refreshToken,
                user: Object.assign(Object.assign({}, session.user), newSession.user)
            }));
            if (options === null || options === void 0 ? void 0 : options.afterRefresh) {
                if (req) {
                    session = await options.afterRefresh(req, res, session);
                } else {
                    session = await options.afterRefresh(session);
                }
            }
            await (0, session_1.set)({
                sessionCache,
                req,
                res,
                session,
                iat
            });
            // Return the new access token.
            return {
                accessToken: tokenSet.access_token
            };
        }
        // We don't have an access token.
        if (!session.accessToken) {
            throw new errors_1.AccessTokenError(errors_1.AccessTokenErrorCode.MISSING_ACCESS_TOKEN, 'The user does not have a valid access token.');
        }
        // The access token is not expired and has sufficient scopes.
        return {
            accessToken: session.accessToken
        };
    };
}
exports.default = accessTokenFactory; //# sourceMappingURL=get-access-token.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/session/touch-session.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const session_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/session/index.js [app-route] (ecmascript)");
/**
 * @ignore
 */ function touchSessionFactory(sessionCache) {
    return async (req, res)=>{
        const [session, iat] = await (0, session_1.get)({
            sessionCache,
            req,
            res
        });
        if (!session) {
            return;
        }
        await (0, session_1.set)({
            req,
            res,
            session,
            sessionCache,
            iat
        });
    };
}
exports.default = touchSessionFactory; //# sourceMappingURL=touch-session.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/session/update-session.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const session_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/session/index.js [app-route] (ecmascript)");
/**
 * @ignore
 */ function updateSessionFactory(sessionCache) {
    return async (reqOrSession, res, newSession)=>{
        const session = res ? newSession : reqOrSession;
        const req = res ? reqOrSession : undefined;
        const [prevSession, iat] = await (0, session_1.get)({
            sessionCache,
            req,
            res
        });
        if (!prevSession || !session || !session.user) {
            return;
        }
        await (0, session_1.set)({
            req,
            res,
            session,
            sessionCache,
            iat
        });
    };
}
exports.default = updateSessionFactory; //# sourceMappingURL=update-session.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/session/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.updateSessionFactory = exports.touchSessionFactory = exports.set = exports.get = exports.SessionCache = exports.accessTokenFactory = exports.sessionFactory = exports.fromTokenEndpointResponse = exports.fromJson = exports.Session = void 0;
var session_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/session/session.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Session", {
    enumerable: true,
    get: function() {
        return __importDefault(session_1).default;
    }
});
Object.defineProperty(exports, "fromJson", {
    enumerable: true,
    get: function() {
        return session_1.fromJson;
    }
});
Object.defineProperty(exports, "fromTokenEndpointResponse", {
    enumerable: true,
    get: function() {
        return session_1.fromTokenEndpointResponse;
    }
});
var get_session_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/session/get-session.js [app-route] (ecmascript)");
Object.defineProperty(exports, "sessionFactory", {
    enumerable: true,
    get: function() {
        return __importDefault(get_session_1).default;
    }
});
var get_access_token_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/session/get-access-token.js [app-route] (ecmascript)");
Object.defineProperty(exports, "accessTokenFactory", {
    enumerable: true,
    get: function() {
        return __importDefault(get_access_token_1).default;
    }
});
var cache_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/session/cache.js [app-route] (ecmascript)");
Object.defineProperty(exports, "SessionCache", {
    enumerable: true,
    get: function() {
        return __importDefault(cache_1).default;
    }
});
Object.defineProperty(exports, "get", {
    enumerable: true,
    get: function() {
        return cache_1.get;
    }
});
Object.defineProperty(exports, "set", {
    enumerable: true,
    get: function() {
        return cache_1.set;
    }
});
var touch_session_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/session/touch-session.js [app-route] (ecmascript)");
Object.defineProperty(exports, "touchSessionFactory", {
    enumerable: true,
    get: function() {
        return __importDefault(touch_session_1).default;
    }
});
var update_session_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/session/update-session.js [app-route] (ecmascript)");
Object.defineProperty(exports, "updateSessionFactory", {
    enumerable: true,
    get: function() {
        return __importDefault(update_session_1).default;
    }
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/version.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = '3.5.0'; //# sourceMappingURL=version.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/shared.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Session = exports.SessionCache = exports.ApplicationError = exports.IdentityProviderError = exports.MissingStateParamError = exports.MalformedStateCookieError = exports.MissingStateCookieError = exports.ProfileHandlerError = exports.LogoutHandlerError = exports.LoginHandlerError = exports.CallbackHandlerError = exports.HandlerError = exports.AccessTokenError = exports.AccessTokenErrorCode = exports.AuthError = exports.telemetry = void 0;
const tslib_1 = __turbopack_require__("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const session_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/session/index.js [app-route] (ecmascript)");
Object.defineProperty(exports, "SessionCache", {
    enumerable: true,
    get: function() {
        return session_1.SessionCache;
    }
});
Object.defineProperty(exports, "Session", {
    enumerable: true,
    get: function() {
        return session_1.Session;
    }
});
const version_1 = tslib_1.__importDefault(__turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/version.js [app-route] (ecmascript)"));
exports.telemetry = {
    name: 'nextjs-auth0',
    version: version_1.default
};
var errors_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/utils/errors.js [app-route] (ecmascript)");
Object.defineProperty(exports, "AuthError", {
    enumerable: true,
    get: function() {
        return errors_1.AuthError;
    }
});
Object.defineProperty(exports, "AccessTokenErrorCode", {
    enumerable: true,
    get: function() {
        return errors_1.AccessTokenErrorCode;
    }
});
Object.defineProperty(exports, "AccessTokenError", {
    enumerable: true,
    get: function() {
        return errors_1.AccessTokenError;
    }
});
Object.defineProperty(exports, "HandlerError", {
    enumerable: true,
    get: function() {
        return errors_1.HandlerError;
    }
});
Object.defineProperty(exports, "CallbackHandlerError", {
    enumerable: true,
    get: function() {
        return errors_1.CallbackHandlerError;
    }
});
Object.defineProperty(exports, "LoginHandlerError", {
    enumerable: true,
    get: function() {
        return errors_1.LoginHandlerError;
    }
});
Object.defineProperty(exports, "LogoutHandlerError", {
    enumerable: true,
    get: function() {
        return errors_1.LogoutHandlerError;
    }
});
Object.defineProperty(exports, "ProfileHandlerError", {
    enumerable: true,
    get: function() {
        return errors_1.ProfileHandlerError;
    }
});
var auth0_session_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/index.js [app-route] (ecmascript)");
Object.defineProperty(exports, "MissingStateCookieError", {
    enumerable: true,
    get: function() {
        return auth0_session_1.MissingStateCookieError;
    }
});
Object.defineProperty(exports, "MalformedStateCookieError", {
    enumerable: true,
    get: function() {
        return auth0_session_1.MalformedStateCookieError;
    }
});
Object.defineProperty(exports, "MissingStateParamError", {
    enumerable: true,
    get: function() {
        return auth0_session_1.MissingStateParamError;
    }
});
Object.defineProperty(exports, "IdentityProviderError", {
    enumerable: true,
    get: function() {
        return auth0_session_1.IdentityProviderError;
    }
});
Object.defineProperty(exports, "ApplicationError", {
    enumerable: true,
    get: function() {
        return auth0_session_1.ApplicationError;
    }
}); //# sourceMappingURL=shared.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/utils/assert.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.assertCtx = exports.assertReqRes = void 0;
const assertReqRes = (req, res)=>{
    if (!req) {
        throw new Error('Request is not available');
    }
    if (!res) {
        throw new Error('Response is not available');
    }
};
exports.assertReqRes = assertReqRes;
const assertCtx = ({ req, res })=>{
    (0, exports.assertReqRes)(req, res);
};
exports.assertCtx = assertCtx; //# sourceMappingURL=assert.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/handlers/router-helpers.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getHandler = void 0;
const req_helpers_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/utils/req-helpers.js [app-route] (ecmascript)");
const getHandler = (appRouteHandler, pageRouteHandler)=>(reqOrOptions, resOrCtx, options)=>{
        if ((0, req_helpers_1.isRequest)(reqOrOptions)) {
            return appRouteHandler(reqOrOptions, resOrCtx, options);
        }
        if ('socket' in reqOrOptions) {
            return pageRouteHandler(reqOrOptions, resOrCtx, options);
        }
        return (req, resOrCtxInner)=>{
            const opts = typeof reqOrOptions === 'function' ? reqOrOptions(req) : reqOrOptions;
            if ((0, req_helpers_1.isRequest)(req)) {
                return appRouteHandler(req, resOrCtxInner, opts);
            }
            return pageRouteHandler(req, resOrCtxInner, opts);
        };
    };
exports.getHandler = getHandler; //# sourceMappingURL=router-helpers.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/handlers/callback.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const server_1 = __turbopack_require__("[project]/node_modules/next/server.js [app-route] (ecmascript)");
const assert_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/utils/assert.js [app-route] (ecmascript)");
const errors_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/utils/errors.js [app-route] (ecmascript)");
const http_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/http/index.js [app-route] (ecmascript)");
const router_helpers_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/handlers/router-helpers.js [app-route] (ecmascript)");
/**
 * @ignore
 */ function handleCallbackFactory(handler, getConfig) {
    const appRouteHandler = appRouteHandlerFactory(handler, getConfig);
    const pageRouteHandler = pageRouteHandlerFactory(handler, getConfig);
    return (0, router_helpers_1.getHandler)(appRouteHandler, pageRouteHandler);
}
exports.default = handleCallbackFactory;
const applyOptions = (req, res, options, config)=>{
    const opts = Object.assign({}, options);
    const idTokenValidator = (afterCallback, organization)=>(session, state)=>{
            if (organization) {
                if (organization.startsWith('org_')) {
                    if (!session.user.org_id) {
                        throw new Error('Organization Id (org_id) claim must be a string present in the ID token');
                    }
                    if (session.user.org_id !== organization) {
                        throw new Error(`Organization Id (org_id) claim value mismatch in the ID token; ` + `expected "${organization}", found "${session.user.org_id}"`);
                    }
                } else {
                    if (!session.user.org_name) {
                        throw new Error('Organization Name (org_name) claim must be a string present in the ID token');
                    }
                    if (session.user.org_name !== organization.toLowerCase()) {
                        throw new Error(`Organization Name (org_name) claim value mismatch in the ID token; ` + `expected "${organization}", found "${session.user.org_name}"`);
                    }
                }
            }
            if (afterCallback) {
                if (res) {
                    return afterCallback(req, res, session, state);
                } else {
                    return afterCallback(req, session, state);
                }
            }
            return session;
        };
    return Object.assign(Object.assign({}, opts), {
        afterCallback: idTokenValidator(opts.afterCallback, opts.organization || config.organization)
    });
};
/**
 * @ignore
 */ const appRouteHandlerFactory = (handler, getConfig)=>async (req, _ctx, options = {})=>{
        try {
            const auth0Req = new http_1.Auth0NextRequest(req);
            const nextConfig = await getConfig(auth0Req);
            const auth0Res = new http_1.Auth0NextResponse(new server_1.NextResponse());
            await handler(auth0Req, auth0Res, applyOptions(req, undefined, options, nextConfig));
            return auth0Res.res;
        } catch (e) {
            throw new errors_1.CallbackHandlerError(e);
        }
    };
/**
 * @ignore
 */ const pageRouteHandlerFactory = (handler, getConfig)=>async (req, res, options = {})=>{
        try {
            const auth0Req = new http_1.Auth0NextApiRequest(req);
            const nextConfig = await getConfig(auth0Req);
            (0, assert_1.assertReqRes)(req, res);
            return await handler(auth0Req, new http_1.Auth0NextApiResponse(res), applyOptions(req, res, options, nextConfig));
        } catch (e) {
            throw new errors_1.CallbackHandlerError(e);
        }
    }; //# sourceMappingURL=callback.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/utils/url-helpers.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 * Helper which tests if a URL can safely be redirected to. Requires the URL to be relative.
 *
 * @param dangerousRedirect
 * @param safeBaseUrl
 */ function toSafeRedirect(dangerousRedirect, safeBaseUrl) {
    let url;
    try {
        url = new URL(dangerousRedirect, safeBaseUrl);
    } catch (e) {
        return undefined;
    }
    if (url.origin === safeBaseUrl.origin) {
        return url.toString();
    }
    return undefined;
}
exports.default = toSafeRedirect; //# sourceMappingURL=url-helpers.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/handlers/login.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const tslib_1 = __turbopack_require__("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const server_1 = __turbopack_require__("[project]/node_modules/next/server.js [app-route] (ecmascript)");
const url_helpers_1 = tslib_1.__importDefault(__turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/utils/url-helpers.js [app-route] (ecmascript)"));
const assert_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/utils/assert.js [app-route] (ecmascript)");
const errors_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/utils/errors.js [app-route] (ecmascript)");
const http_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/http/index.js [app-route] (ecmascript)");
const router_helpers_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/handlers/router-helpers.js [app-route] (ecmascript)");
/**
 * @ignore
 */ function handleLoginFactory(handler, getConfig) {
    const appRouteHandler = appRouteHandlerFactory(handler, getConfig);
    const pageRouteHandler = pageRouteHandlerFactory(handler, getConfig);
    return (0, router_helpers_1.getHandler)(appRouteHandler, pageRouteHandler);
}
exports.default = handleLoginFactory;
/**
 * @ignore
 */ const applyOptions = (req, options, dangerousReturnTo, config)=>{
    var _a;
    let opts;
    let getLoginState;
    // eslint-disable-next-line prefer-const
    ({ getLoginState } = options), opts = tslib_1.__rest(options, [
        "getLoginState"
    ]);
    if (dangerousReturnTo) {
        const safeBaseUrl = new URL(((_a = options.authorizationParams) === null || _a === void 0 ? void 0 : _a.redirect_uri) || config.baseURL);
        const returnTo = (0, url_helpers_1.default)(dangerousReturnTo, safeBaseUrl);
        opts = Object.assign(Object.assign({}, opts), {
            returnTo
        });
    }
    if (config.organization) {
        opts = Object.assign(Object.assign({}, opts), {
            authorizationParams: Object.assign({
                organization: config.organization
            }, opts.authorizationParams)
        });
    }
    if (getLoginState) {
        opts.getLoginState = (_opts)=>getLoginState(req, _opts);
    }
    return opts;
};
/**
 * @ignore
 */ const appRouteHandlerFactory = (handler, getConfig)=>async (req, _ctx, options = {})=>{
        try {
            const auth0Req = new http_1.Auth0NextRequest(req);
            const config = await getConfig(auth0Req);
            const url = new URL(req.url);
            const dangerousReturnTo = url.searchParams.get('returnTo');
            const auth0Res = new http_1.Auth0NextResponse(new server_1.NextResponse());
            await handler(auth0Req, auth0Res, applyOptions(req, options, dangerousReturnTo, config));
            return auth0Res.res;
        } catch (e) {
            throw new errors_1.LoginHandlerError(e);
        }
    };
/**
 * @ignore
 */ const pageRouteHandlerFactory = (handler, getConfig)=>async (req, res, options = {})=>{
        try {
            const auth0Req = new http_1.Auth0NextApiRequest(req);
            const config = await getConfig(auth0Req);
            (0, assert_1.assertReqRes)(req, res);
            const dangerousReturnTo = req.query.returnTo && Array.isArray(req.query.returnTo) ? req.query.returnTo[0] : req.query.returnTo;
            return await handler(auth0Req, new http_1.Auth0NextApiResponse(res), applyOptions(req, options, dangerousReturnTo, config));
        } catch (e) {
            throw new errors_1.LoginHandlerError(e);
        }
    }; //# sourceMappingURL=login.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/handlers/logout.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const server_1 = __turbopack_require__("[project]/node_modules/next/server.js [app-route] (ecmascript)");
const assert_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/utils/assert.js [app-route] (ecmascript)");
const errors_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/utils/errors.js [app-route] (ecmascript)");
const http_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/http/index.js [app-route] (ecmascript)");
const router_helpers_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/handlers/router-helpers.js [app-route] (ecmascript)");
/**
 * @ignore
 */ function handleLogoutFactory(handler) {
    const appRouteHandler = appRouteHandlerFactory(handler);
    const pageRouteHandler = pageRouteHandlerFactory(handler);
    return (0, router_helpers_1.getHandler)(appRouteHandler, pageRouteHandler);
}
exports.default = handleLogoutFactory;
const appRouteHandlerFactory = (handler)=>async (req, _ctx, options = {})=>{
        try {
            const auth0Res = new http_1.Auth0NextResponse(new server_1.NextResponse());
            await handler(new http_1.Auth0NextRequest(req), auth0Res, options);
            return auth0Res.res;
        } catch (e) {
            throw new errors_1.LogoutHandlerError(e);
        }
    };
const pageRouteHandlerFactory = (handler)=>async (req, res, options = {})=>{
        try {
            (0, assert_1.assertReqRes)(req, res);
            return await handler(new http_1.Auth0NextApiRequest(req), new http_1.Auth0NextApiResponse(res), options);
        } catch (e) {
            throw new errors_1.LogoutHandlerError(e);
        }
    }; //# sourceMappingURL=logout.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/handlers/backchannel-logout.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const server_1 = __turbopack_require__("[project]/node_modules/next/server.js [app-route] (ecmascript)");
const http_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/http/index.js [app-route] (ecmascript)");
const router_helpers_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/handlers/router-helpers.js [app-route] (ecmascript)");
/**
 * @ignore
 */ function handleBackchannelLogoutFactory(handler, getConfig) {
    const appRouteHandler = appRouteHandlerFactory(handler, getConfig);
    const pageRouteHandler = pageRouteHandlerFactory(handler, getConfig);
    return (0, router_helpers_1.getHandler)(appRouteHandler, pageRouteHandler);
}
exports.default = handleBackchannelLogoutFactory;
const appRouteHandlerFactory = (handler, getConfig)=>async (req)=>{
        try {
            const auth0Req = new http_1.Auth0NextRequest(req);
            const config = await getConfig(auth0Req);
            if (!config.backchannelLogout) {
                return new server_1.NextResponse('Back-Channel Logout is not enabled.', {
                    status: 404
                });
            }
            const auth0Res = new http_1.Auth0NextResponse(new server_1.NextResponse());
            await handler(auth0Req, auth0Res);
            return auth0Res.res;
        } catch (e) {
            return server_1.NextResponse.json({
                error: e.code || 'unknown_error',
                error_description: e.description || e.message
            }, {
                status: 400,
                headers: {
                    'cache-control': 'no-store'
                }
            });
        }
    };
const pageRouteHandlerFactory = (handler, getConfig)=>async (req, res)=>{
        try {
            const auth0Req = new http_1.Auth0NextApiRequest(req);
            const config = await getConfig(auth0Req);
            if (!config.backchannelLogout) {
                res.status(404).end('Back-Channel Logout is not enabled.');
                return;
            }
            return await handler(auth0Req, new http_1.Auth0NextApiResponse(res));
        } catch (e) {
            res.setHeader('cache-control', 'no-store');
            res.status(400).json({
                error: e.code || 'unknown_error',
                error_description: e.description || e.message
            });
        }
    }; //# sourceMappingURL=backchannel-logout.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/handlers/profile.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const server_1 = __turbopack_require__("[project]/node_modules/next/server.js [app-route] (ecmascript)");
const session_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/session/index.js [app-route] (ecmascript)");
const assert_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/utils/assert.js [app-route] (ecmascript)");
const errors_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/utils/errors.js [app-route] (ecmascript)");
const router_helpers_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/handlers/router-helpers.js [app-route] (ecmascript)");
const http_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/http/index.js [app-route] (ecmascript)");
/**
 * @ignore
 */ function profileHandler(getConfig, getClient, getAccessToken, sessionCache) {
    const appRouteHandler = appRouteHandlerFactory(getConfig, getClient, getAccessToken, sessionCache);
    const pageRouteHandler = pageRouteHandlerFactory(getConfig, getClient, getAccessToken, sessionCache);
    return (0, router_helpers_1.getHandler)(appRouteHandler, pageRouteHandler);
}
exports.default = profileHandler;
/**
 * @ignore
 */ const appRouteHandlerFactory = (getConfig, getClient, getAccessToken, sessionCache)=>async (req, _ctx, options = {})=>{
        try {
            const config = await getConfig(new http_1.Auth0NextRequest(req));
            const client = await getClient(config);
            const res = new server_1.NextResponse();
            if (!await sessionCache.isAuthenticated(req, res)) {
                const emptyRes = new server_1.NextResponse(null, {
                    status: 204
                });
                res.headers.forEach((val, key)=>emptyRes.headers.set(key, val));
                return emptyRes;
            }
            const session = await sessionCache.get(req, res);
            res.headers.set('Cache-Control', 'no-store');
            if (options.refetch) {
                const { accessToken } = await getAccessToken(req, res);
                if (!accessToken) {
                    throw new Error('No access token available to refetch the profile');
                }
                const userInfo = await client.userinfo(accessToken);
                let newSession = (0, session_1.fromJson)(Object.assign(Object.assign({}, session), {
                    user: Object.assign(Object.assign({}, session.user), userInfo)
                }));
                if (options.afterRefetch) {
                    newSession = await options.afterRefetch(req, newSession);
                }
                await sessionCache.set(req, res, newSession);
                return server_1.NextResponse.json(newSession.user, res);
            }
            return server_1.NextResponse.json(session.user, res);
        } catch (e) {
            throw new errors_1.ProfileHandlerError(e);
        }
    };
/**
 * @ignore
 */ const pageRouteHandlerFactory = (getConfig, getClient, getAccessToken, sessionCache)=>async (req, res, options = {})=>{
        try {
            (0, assert_1.assertReqRes)(req, res);
            const config = await getConfig(new http_1.Auth0NextApiRequest(req));
            const client = await getClient(config);
            if (!await sessionCache.isAuthenticated(req, res)) {
                res.status(204).end();
                return;
            }
            const session = await sessionCache.get(req, res);
            res.setHeader('Cache-Control', 'no-store');
            if (options.refetch) {
                const { accessToken } = await getAccessToken(req, res);
                if (!accessToken) {
                    throw new Error('No access token available to refetch the profile');
                }
                const userInfo = await client.userinfo(accessToken);
                let newSession = (0, session_1.fromJson)(Object.assign(Object.assign({}, session), {
                    user: Object.assign(Object.assign({}, session.user), userInfo)
                }));
                if (options.afterRefetch) {
                    newSession = await options.afterRefetch(req, res, newSession);
                }
                await sessionCache.set(req, res, newSession);
                res.json(newSession.user);
                return;
            }
            res.json(session.user);
        } catch (e) {
            throw new errors_1.ProfileHandlerError(e);
        }
    }; //# sourceMappingURL=profile.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/handlers/auth.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const tslib_1 = __turbopack_require__("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const req_helpers_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/utils/req-helpers.js [app-route] (ecmascript)");
/**
 * @ignore
 */ const defaultPageRouterOnError = (_req, res, error)=>{
    console.error(error);
    res.status(error.status || 500).end();
};
/**
 * @ignore
 */ const defaultAppRouterOnError = (_req, error)=>{
    console.error(error);
};
/**
 * @ignore
 */ function handlerFactory({ handleLogin, handleLogout, handleCallback, handleProfile, handleBackchannelLogout }) {
    return (_a = {})=>{
        var { onError } = _a, handlers = tslib_1.__rest(_a, [
            "onError"
        ]);
        const customHandlers = Object.assign({
            login: handleLogin,
            logout: handleLogout,
            callback: handleCallback,
            'backchannel-logout': handleBackchannelLogout,
            me: handlers.profile || handleProfile
        }, handlers);
        const appRouteHandler = appRouteHandlerFactory(customHandlers, onError);
        const pageRouteHandler = pageRouteHandlerFactory(customHandlers, onError);
        return (req, resOrCtx)=>{
            if ((0, req_helpers_1.isRequest)(req)) {
                return appRouteHandler(req, resOrCtx);
            }
            return pageRouteHandler(req, resOrCtx);
        };
    };
}
exports.default = handlerFactory;
/**
 * @ignore
 */ const appRouteHandlerFactory = (customHandlers, onError)=>async (req, ctx)=>{
        const { params } = ctx;
        let route = params.auth0;
        if (Array.isArray(route)) {
            let otherRoutes;
            [route, ...otherRoutes] = route;
            if (otherRoutes.length) {
                return new Response(null, {
                    status: 404
                });
            }
        }
        const handler = route && customHandlers.hasOwnProperty(route) && customHandlers[route];
        try {
            if (handler) {
                return await handler(req, ctx);
            } else {
                return new Response(null, {
                    status: 404
                });
            }
        } catch (error) {
            const res = await (onError || defaultAppRouterOnError)(req, error);
            return res || new Response(null, {
                status: error.status || 500
            });
        }
    };
/**
 * @ignore
 */ const pageRouteHandlerFactory = (customHandlers, onError)=>async (req, res)=>{
        let { query: { auth0: route } } = req;
        if (Array.isArray(route)) {
            let otherRoutes;
            [route, ...otherRoutes] = route;
            if (otherRoutes.length) {
                res.status(404).end();
                return;
            }
        }
        try {
            const handler = route && customHandlers.hasOwnProperty(route) && customHandlers[route];
            if (handler) {
                await handler(req, res);
            } else {
                res.status(404).end();
            }
        } catch (error) {
            await (onError || defaultPageRouterOnError)(req, res, error);
            if (!res.writableEnded) {
                // 200 is the default, so we assume it has not been set in the custom error handler if it equals 200
                res.status(res.statusCode === 200 ? 500 : res.statusCode).end();
            }
        }
    }; //# sourceMappingURL=auth.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/handlers/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.handlerFactory = exports.profileHandler = exports.backchannelLogoutHandler = exports.logoutHandler = exports.loginHandler = exports.callbackHandler = void 0;
var callback_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/handlers/callback.js [app-route] (ecmascript)");
Object.defineProperty(exports, "callbackHandler", {
    enumerable: true,
    get: function() {
        return __importDefault(callback_1).default;
    }
});
var login_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/handlers/login.js [app-route] (ecmascript)");
Object.defineProperty(exports, "loginHandler", {
    enumerable: true,
    get: function() {
        return __importDefault(login_1).default;
    }
});
var logout_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/handlers/logout.js [app-route] (ecmascript)");
Object.defineProperty(exports, "logoutHandler", {
    enumerable: true,
    get: function() {
        return __importDefault(logout_1).default;
    }
});
var backchannel_logout_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/handlers/backchannel-logout.js [app-route] (ecmascript)");
Object.defineProperty(exports, "backchannelLogoutHandler", {
    enumerable: true,
    get: function() {
        return __importDefault(backchannel_logout_1).default;
    }
});
var profile_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/handlers/profile.js [app-route] (ecmascript)");
Object.defineProperty(exports, "profileHandler", {
    enumerable: true,
    get: function() {
        return __importDefault(profile_1).default;
    }
});
var auth_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/handlers/auth.js [app-route] (ecmascript)");
Object.defineProperty(exports, "handlerFactory", {
    enumerable: true,
    get: function() {
        return __importDefault(auth_1).default;
    }
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/helpers/with-api-auth-required.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const server_1 = __turbopack_require__("[project]/node_modules/next/server.js [app-route] (ecmascript)");
const session_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/session/index.js [app-route] (ecmascript)");
const assert_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/utils/assert.js [app-route] (ecmascript)");
const req_helpers_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/utils/req-helpers.js [app-route] (ecmascript)");
/**
 * @ignore
 */ function withApiAuthFactory(sessionCache) {
    const pageRouteHandler = pageRouteHandlerFactory(sessionCache);
    const appRouteHandler = appRouteHandlerFactory(sessionCache);
    return (apiRoute)=>(req, resOrParams)=>{
            if ((0, req_helpers_1.isRequest)(req)) {
                return appRouteHandler(apiRoute)(req, resOrParams);
            }
            return pageRouteHandler(apiRoute)(req, resOrParams);
        };
}
exports.default = withApiAuthFactory;
/**
 * @ignore
 */ const appRouteHandlerFactory = (sessionCache)=>(apiRoute)=>async (req, params)=>{
            const res = new server_1.NextResponse();
            const [session] = await (0, session_1.get)({
                sessionCache,
                req,
                res
            });
            if (!session || !session.user) {
                return server_1.NextResponse.json({
                    error: 'not_authenticated',
                    description: 'The user does not have an active session or is not authenticated'
                }, {
                    status: 401
                });
            }
            const apiRes = await apiRoute(req, params);
            const nextApiRes = apiRes instanceof server_1.NextResponse ? apiRes : new server_1.NextResponse(apiRes.body, apiRes);
            for (const cookie of res.cookies.getAll()){
                if (!nextApiRes.cookies.get(cookie.name)) {
                    nextApiRes.cookies.set(cookie);
                }
            }
            return nextApiRes;
        };
/**
 * @ignore
 */ const pageRouteHandlerFactory = (sessionCache)=>(apiRoute)=>async (req, res)=>{
            (0, assert_1.assertReqRes)(req, res);
            const session = await sessionCache.get(req, res);
            if (!session || !session.user) {
                res.status(401).json({
                    error: 'not_authenticated',
                    description: 'The user does not have an active session or is not authenticated'
                });
                return;
            }
            await apiRoute(req, res);
        }; //# sourceMappingURL=with-api-auth-required.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/helpers/with-page-auth-required.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const session_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/session/index.js [app-route] (ecmascript)");
const assert_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/utils/assert.js [app-route] (ecmascript)");
const http_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/http/index.js [app-route] (ecmascript)");
const http_2 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/http/index.js [app-route] (ecmascript)");
/**
 * @ignore
 */ function withPageAuthRequiredFactory(getConfig, sessionCache) {
    const appRouteHandler = appRouteHandlerFactory(getConfig, sessionCache);
    const pageRouteHandler = pageRouteHandlerFactory(getConfig, sessionCache);
    return (fnOrOpts, opts)=>{
        if (typeof fnOrOpts === 'function') {
            return appRouteHandler(fnOrOpts, opts);
        }
        return pageRouteHandler(fnOrOpts);
    };
}
exports.default = withPageAuthRequiredFactory;
/**
 * @ignore
 */ const appRouteHandlerFactory = (getConfig, sessionCache)=>(handler, opts = {})=>async (params)=>{
            const { routes: { login: loginUrl } } = await getConfig(new http_1.Auth0NextRequestCookies());
            const [session] = await (0, session_1.get)({
                sessionCache
            });
            if (!(session === null || session === void 0 ? void 0 : session.user)) {
                const returnTo = typeof opts.returnTo === 'function' ? await opts.returnTo(params) : opts.returnTo;
                // eslint-disable-next-line @typescript-eslint/no-var-requires
                const { redirect } = __turbopack_require__("[project]/node_modules/next/dist/api/navigation.react-server.js [app-route] (ecmascript)");
                redirect(`${loginUrl}${opts.returnTo ? `?returnTo=${returnTo}` : ''}`);
            }
            return handler(params);
        };
/**
 * @ignore
 */ const pageRouteHandlerFactory = (getConfig, sessionCache)=>({ getServerSideProps, returnTo } = {})=>async (ctx)=>{
            (0, assert_1.assertCtx)(ctx);
            const { routes: { login: loginUrl } } = await getConfig(new http_2.NodeRequest(ctx.req));
            const session = await sessionCache.get(ctx.req, ctx.res);
            if (!(session === null || session === void 0 ? void 0 : session.user)) {
                return {
                    redirect: {
                        destination: `${loginUrl}?returnTo=${encodeURIComponent(returnTo || ctx.resolvedUrl)}`,
                        permanent: false
                    }
                };
            }
            let ret = {
                props: {}
            };
            if (getServerSideProps) {
                ret = await getServerSideProps(ctx);
            }
            if (ret.props instanceof Promise) {
                return Object.assign(Object.assign({}, ret), {
                    props: ret.props.then((props)=>Object.assign({
                            user: session.user
                        }, props))
                });
            }
            return Object.assign(Object.assign({}, ret), {
                props: Object.assign({
                    user: session.user
                }, ret.props)
            });
        }; //# sourceMappingURL=with-page-auth-required.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/helpers/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.withPageAuthRequiredFactory = exports.withApiAuthRequiredFactory = void 0;
var with_api_auth_required_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/helpers/with-api-auth-required.js [app-route] (ecmascript)");
Object.defineProperty(exports, "withApiAuthRequiredFactory", {
    enumerable: true,
    get: function() {
        return __importDefault(with_api_auth_required_1).default;
    }
});
var with_page_auth_required_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/helpers/with-page-auth-required.js [app-route] (ecmascript)");
Object.defineProperty(exports, "withPageAuthRequiredFactory", {
    enumerable: true,
    get: function() {
        return __importDefault(with_page_auth_required_1).default;
    }
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/config.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.configSingletonGetter = exports.getConfig = void 0;
const tslib_1 = __turbopack_require__("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const get_config_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/get-config.js [app-route] (ecmascript)");
/**
 * @ignore
 */ const FALSEY = [
    'n',
    'no',
    'false',
    '0',
    'off'
];
/**
 * @ignore
 */ const bool = (param, defaultValue)=>{
    if (param === undefined || param === '') return defaultValue;
    if (param && typeof param === 'string') return !FALSEY.includes(param.toLowerCase().trim());
    return !!param;
};
/**
 * @ignore
 */ const num = (param)=>param === undefined || param === '' ? undefined : +param;
/**
 * @ignore
 */ const array = (param)=>param === undefined || param === '' ? undefined : param.replace(/\s/g, '').split(',');
/**
 * @ignore
 */ const getConfig = (params = {})=>{
    var _a, _b, _c, _d;
    // Don't use destructuring here so that the `DefinePlugin` can replace any env vars specified in `next.config.js`
    const AUTH0_SECRET = process.env.AUTH0_SECRET;
    const AUTH0_ISSUER_BASE_URL = process.env.AUTH0_ISSUER_BASE_URL;
    const AUTH0_BASE_URL = process.env.AUTH0_BASE_URL || process.env.NEXT_PUBLIC_AUTH0_BASE_URL;
    const AUTH0_CLIENT_ID = process.env.AUTH0_CLIENT_ID;
    const AUTH0_CLIENT_SECRET = process.env.AUTH0_CLIENT_SECRET;
    const AUTH0_CLOCK_TOLERANCE = process.env.AUTH0_CLOCK_TOLERANCE;
    const AUTH0_HTTP_TIMEOUT = process.env.AUTH0_HTTP_TIMEOUT;
    const AUTH0_ENABLE_TELEMETRY = process.env.AUTH0_ENABLE_TELEMETRY;
    const AUTH0_IDP_LOGOUT = process.env.AUTH0_IDP_LOGOUT;
    const AUTH0_LOGOUT = process.env.AUTH0_LOGOUT;
    const AUTH0_ID_TOKEN_SIGNING_ALG = process.env.AUTH0_ID_TOKEN_SIGNING_ALG;
    const AUTH0_LEGACY_SAME_SITE_COOKIE = process.env.AUTH0_LEGACY_SAME_SITE_COOKIE;
    const AUTH0_IDENTITY_CLAIM_FILTER = process.env.AUTH0_IDENTITY_CLAIM_FILTER;
    const AUTH0_PUSHED_AUTHORIZATION_REQUESTS = process.env.AUTH0_PUSHED_AUTHORIZATION_REQUESTS;
    const AUTH0_CALLBACK = process.env.AUTH0_CALLBACK;
    const AUTH0_POST_LOGOUT_REDIRECT = process.env.AUTH0_POST_LOGOUT_REDIRECT;
    const AUTH0_AUDIENCE = process.env.AUTH0_AUDIENCE;
    const AUTH0_SCOPE = process.env.AUTH0_SCOPE;
    const AUTH0_ORGANIZATION = process.env.AUTH0_ORGANIZATION;
    const AUTH0_SESSION_NAME = process.env.AUTH0_SESSION_NAME;
    const AUTH0_SESSION_ROLLING = process.env.AUTH0_SESSION_ROLLING;
    const AUTH0_SESSION_ROLLING_DURATION = process.env.AUTH0_SESSION_ROLLING_DURATION;
    const AUTH0_SESSION_ABSOLUTE_DURATION = process.env.AUTH0_SESSION_ABSOLUTE_DURATION;
    const AUTH0_SESSION_AUTO_SAVE = process.env.AUTH0_SESSION_AUTO_SAVE;
    const AUTH0_SESSION_STORE_ID_TOKEN = process.env.AUTH0_SESSION_STORE_ID_TOKEN;
    const AUTH0_COOKIE_DOMAIN = process.env.AUTH0_COOKIE_DOMAIN;
    const AUTH0_COOKIE_PATH = process.env.AUTH0_COOKIE_PATH;
    const AUTH0_COOKIE_TRANSIENT = process.env.AUTH0_COOKIE_TRANSIENT;
    const AUTH0_COOKIE_HTTP_ONLY = process.env.AUTH0_COOKIE_HTTP_ONLY;
    const AUTH0_COOKIE_SECURE = process.env.AUTH0_COOKIE_SECURE;
    const AUTH0_COOKIE_SAME_SITE = process.env.AUTH0_COOKIE_SAME_SITE;
    const AUTH0_CLIENT_ASSERTION_SIGNING_KEY = process.env.AUTH0_CLIENT_ASSERTION_SIGNING_KEY;
    const AUTH0_CLIENT_ASSERTION_SIGNING_ALG = process.env.AUTH0_CLIENT_ASSERTION_SIGNING_ALG;
    const AUTH0_TRANSACTION_COOKIE_NAME = process.env.AUTH0_TRANSACTION_COOKIE_NAME;
    const AUTH0_TRANSACTION_COOKIE_DOMAIN = process.env.AUTH0_TRANSACTION_COOKIE_DOMAIN;
    const AUTH0_TRANSACTION_COOKIE_PATH = process.env.AUTH0_TRANSACTION_COOKIE_PATH;
    const AUTH0_TRANSACTION_COOKIE_SAME_SITE = process.env.AUTH0_TRANSACTION_COOKIE_SAME_SITE;
    const AUTH0_TRANSACTION_COOKIE_SECURE = process.env.AUTH0_TRANSACTION_COOKIE_SECURE;
    const baseURL = AUTH0_BASE_URL && !/^https?:\/\//.test(AUTH0_BASE_URL) ? `https://${AUTH0_BASE_URL}` : AUTH0_BASE_URL;
    const { organization } = params, baseParams = tslib_1.__rest(params, [
        "organization"
    ]);
    const baseConfig = (0, get_config_1.get)(Object.assign(Object.assign({
        secret: AUTH0_SECRET,
        issuerBaseURL: AUTH0_ISSUER_BASE_URL,
        baseURL: baseURL,
        clientID: AUTH0_CLIENT_ID,
        clientSecret: AUTH0_CLIENT_SECRET,
        clockTolerance: num(AUTH0_CLOCK_TOLERANCE),
        httpTimeout: num(AUTH0_HTTP_TIMEOUT),
        enableTelemetry: bool(AUTH0_ENABLE_TELEMETRY),
        idpLogout: bool(AUTH0_IDP_LOGOUT, true),
        auth0Logout: bool(AUTH0_LOGOUT, true),
        idTokenSigningAlg: AUTH0_ID_TOKEN_SIGNING_ALG,
        legacySameSiteCookie: bool(AUTH0_LEGACY_SAME_SITE_COOKIE),
        identityClaimFilter: array(AUTH0_IDENTITY_CLAIM_FILTER),
        pushedAuthorizationRequests: bool(AUTH0_PUSHED_AUTHORIZATION_REQUESTS, false)
    }, baseParams), {
        authorizationParams: Object.assign({
            response_type: 'code',
            audience: AUTH0_AUDIENCE,
            scope: AUTH0_SCOPE
        }, baseParams.authorizationParams),
        session: Object.assign(Object.assign({
            name: AUTH0_SESSION_NAME,
            rolling: bool(AUTH0_SESSION_ROLLING),
            rollingDuration: AUTH0_SESSION_ROLLING_DURATION && isNaN(Number(AUTH0_SESSION_ROLLING_DURATION)) ? bool(AUTH0_SESSION_ROLLING_DURATION) : num(AUTH0_SESSION_ROLLING_DURATION),
            absoluteDuration: AUTH0_SESSION_ABSOLUTE_DURATION && isNaN(Number(AUTH0_SESSION_ABSOLUTE_DURATION)) ? bool(AUTH0_SESSION_ABSOLUTE_DURATION) : num(AUTH0_SESSION_ABSOLUTE_DURATION),
            autoSave: bool(AUTH0_SESSION_AUTO_SAVE, true),
            storeIDToken: bool(AUTH0_SESSION_STORE_ID_TOKEN)
        }, baseParams.session), {
            cookie: Object.assign({
                domain: AUTH0_COOKIE_DOMAIN,
                path: AUTH0_COOKIE_PATH || '/',
                transient: bool(AUTH0_COOKIE_TRANSIENT),
                httpOnly: bool(AUTH0_COOKIE_HTTP_ONLY),
                secure: bool(AUTH0_COOKIE_SECURE),
                sameSite: AUTH0_COOKIE_SAME_SITE
            }, (_a = baseParams.session) === null || _a === void 0 ? void 0 : _a.cookie)
        }),
        routes: {
            callback: ((_b = baseParams.routes) === null || _b === void 0 ? void 0 : _b.callback) || AUTH0_CALLBACK || '/api/auth/callback',
            postLogoutRedirect: ((_c = baseParams.routes) === null || _c === void 0 ? void 0 : _c.postLogoutRedirect) || AUTH0_POST_LOGOUT_REDIRECT
        },
        clientAssertionSigningKey: AUTH0_CLIENT_ASSERTION_SIGNING_KEY,
        clientAssertionSigningAlg: AUTH0_CLIENT_ASSERTION_SIGNING_ALG,
        transactionCookie: Object.assign({
            name: AUTH0_TRANSACTION_COOKIE_NAME,
            domain: AUTH0_TRANSACTION_COOKIE_DOMAIN,
            path: AUTH0_TRANSACTION_COOKIE_PATH || '/',
            secure: bool(AUTH0_TRANSACTION_COOKIE_SECURE),
            sameSite: AUTH0_TRANSACTION_COOKIE_SAME_SITE
        }, baseParams.transactionCookie)
    }));
    return Object.assign(Object.assign({}, baseConfig), {
        organization: organization || AUTH0_ORGANIZATION,
        routes: Object.assign(Object.assign({}, baseConfig.routes), {
            login: ((_d = baseParams.routes) === null || _d === void 0 ? void 0 : _d.login) || process.env.NEXT_PUBLIC_AUTH0_LOGIN || '/api/auth/login'
        })
    });
};
exports.getConfig = getConfig;
const configSingletonGetter = (params = {}, genId)=>{
    let config;
    return (req)=>{
        if (!config) {
            // Bails out of static rendering for Server Components
            // Need to query cookies because Server Components don't have access to URL
            req.getCookies();
            if ('getUrl' in req) {
                // Bail out of static rendering for API Routes
                // Reading cookies is not always enough https://github.com/vercel/next.js/issues/49006
                req.getUrl();
            }
            config = (0, exports.getConfig)(Object.assign(Object.assign({}, params), {
                session: Object.assign({
                    genId
                }, params.session)
            }));
        }
        return config;
    };
};
exports.configSingletonGetter = configSingletonGetter; //# sourceMappingURL=config.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/helpers/with-middleware-auth-required.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const server_1 = __turbopack_require__("[project]/node_modules/next/server.js [app-route] (ecmascript)");
const http_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/http/index.js [app-route] (ecmascript)");
/**
 * @ignore
 */ function withMiddlewareAuthRequiredFactory(getConfig, sessionCache) {
    return function withMiddlewareAuthRequired(opts) {
        return async function wrappedMiddleware(...args) {
            const [req] = args;
            const { routes: { login, callback } } = await getConfig(new http_1.Auth0NextRequest(req));
            let middleware;
            const { pathname, origin, search } = req.nextUrl;
            let returnTo = `${pathname}${search}`;
            if (typeof opts === 'function') {
                middleware = opts;
            } else if (opts) {
                middleware = opts.middleware;
                returnTo = (typeof opts.returnTo === 'function' ? await opts.returnTo(req) : opts.returnTo) || returnTo;
            }
            const ignorePaths = [
                login,
                callback,
                '/_next',
                '/favicon.ico'
            ];
            if (ignorePaths.some((p)=>pathname.startsWith(p))) {
                return;
            }
            const authRes = server_1.NextResponse.next();
            const session = await sessionCache.get(req, authRes);
            if (!(session === null || session === void 0 ? void 0 : session.user)) {
                if (pathname.startsWith('/api')) {
                    return server_1.NextResponse.json({
                        error: 'not_authenticated',
                        description: 'The user does not have an active session or is not authenticated'
                    }, {
                        status: 401
                    });
                }
                return server_1.NextResponse.redirect(new URL(`${login}?returnTo=${encodeURIComponent(returnTo)}`, origin));
            }
            const res = await (middleware && middleware(...args));
            if (res) {
                const nextRes = new server_1.NextResponse(res.body, res);
                const cookies = authRes.cookies.getAll();
                if ('cookies' in res) {
                    for (const cookie of res.cookies.getAll()){
                        nextRes.cookies.set(cookie);
                    }
                }
                for (const cookie of cookies){
                    if (!nextRes.cookies.get(cookie.name)) {
                        nextRes.cookies.set(cookie);
                    }
                }
                return nextRes;
            } else {
                return authRes;
            }
        };
    };
}
exports.default = withMiddlewareAuthRequiredFactory; //# sourceMappingURL=with-middleware-auth-required.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/init.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports._initAuth = void 0;
const tslib_1 = __turbopack_require__("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const auth0_session_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/index.js [app-route] (ecmascript)");
const handlers_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/handlers/index.js [app-route] (ecmascript)");
const session_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/session/index.js [app-route] (ecmascript)");
const helpers_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/helpers/index.js [app-route] (ecmascript)");
const config_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/config.js [app-route] (ecmascript)");
const shared_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/shared.js [app-route] (ecmascript)");
const with_middleware_auth_required_1 = tslib_1.__importDefault(__turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/helpers/with-middleware-auth-required.js [app-route] (ecmascript)"));
const _initAuth = ({ params, genId, clientGetter })=>{
    const getConfig = (0, config_1.configSingletonGetter)(params, genId);
    const getClient = clientGetter(shared_1.telemetry);
    // Init base layer (with base config)
    const transientStore = new auth0_session_1.TransientStore(getConfig);
    const sessionCache = new session_1.SessionCache(getConfig);
    const baseHandleLogin = (0, auth0_session_1.loginHandler)(getConfig, getClient, transientStore);
    const baseHandleLogout = (0, auth0_session_1.logoutHandler)(getConfig, getClient, sessionCache);
    const baseHandleCallback = (0, auth0_session_1.callbackHandler)(getConfig, getClient, sessionCache, transientStore);
    const baseHandleBackchannelLogout = (0, auth0_session_1.backchannelLogoutHandler)(getConfig, getClient);
    // Init Next layer (with next config)
    const getSession = (0, session_1.sessionFactory)(sessionCache);
    const touchSession = (0, session_1.touchSessionFactory)(sessionCache);
    const updateSession = (0, session_1.updateSessionFactory)(sessionCache);
    const getAccessToken = (0, session_1.accessTokenFactory)(getConfig, getClient, sessionCache);
    const withApiAuthRequired = (0, helpers_1.withApiAuthRequiredFactory)(sessionCache);
    const withPageAuthRequired = (0, helpers_1.withPageAuthRequiredFactory)(getConfig, sessionCache);
    const handleLogin = (0, handlers_1.loginHandler)(baseHandleLogin, getConfig);
    const handleLogout = (0, handlers_1.logoutHandler)(baseHandleLogout);
    const handleCallback = (0, handlers_1.callbackHandler)(baseHandleCallback, getConfig);
    const handleBackchannelLogout = (0, handlers_1.backchannelLogoutHandler)(baseHandleBackchannelLogout, getConfig);
    const handleProfile = (0, handlers_1.profileHandler)(getConfig, getClient, getAccessToken, sessionCache);
    const handleAuth = (0, handlers_1.handlerFactory)({
        handleLogin,
        handleLogout,
        handleCallback,
        handleProfile,
        handleBackchannelLogout
    });
    const withMiddlewareAuthRequired = (0, with_middleware_auth_required_1.default)(getConfig, sessionCache);
    return {
        getSession,
        touchSession,
        updateSession,
        getAccessToken,
        withApiAuthRequired,
        withPageAuthRequired,
        handleLogin,
        handleLogout,
        handleCallback,
        handleBackchannelLogout,
        handleProfile,
        handleAuth,
        withMiddlewareAuthRequired
    };
};
exports._initAuth = _initAuth; //# sourceMappingURL=init.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/utils/instance-check.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setIsUsingOwnInstance = exports.setIsUsingNamedExports = void 0;
let isUsingNamedExports = false;
let isUsingOwnInstance = false;
const instanceCheck = ()=>{
    if (isUsingNamedExports && isUsingOwnInstance) {
        throw new Error('You cannot mix creating your own instance with `initAuth0` and using named ' + "exports like `import { handleAuth } from '@auth0/nextjs-auth0'`");
    }
};
const setIsUsingNamedExports = ()=>{
    isUsingNamedExports = true;
    instanceCheck();
};
exports.setIsUsingNamedExports = setIsUsingNamedExports;
const setIsUsingOwnInstance = ()=>{
    isUsingOwnInstance = true;
    instanceCheck();
};
exports.setIsUsingOwnInstance = setIsUsingOwnInstance; //# sourceMappingURL=instance-check.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/client/node-client.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.clientGetter = exports.NodeClient = void 0;
const tslib_1 = __turbopack_require__("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const abstract_client_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/client/abstract-client.js [app-route] (ecmascript)");
const openid_client_1 = __turbopack_require__("[project]/node_modules/openid-client/lib/index.js [app-route] (ecmascript)");
const errors_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/utils/errors.js [app-route] (ecmascript)");
const crypto_1 = __turbopack_require__("[externals]/crypto [external] (crypto, cjs)");
const jose_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/index.js [app-route] (ecmascript)");
const url_join_1 = tslib_1.__importDefault(__turbopack_require__("[project]/node_modules/url-join/lib/url-join.js [app-route] (ecmascript)"));
const debug_1 = tslib_1.__importDefault(__turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/utils/debug.js [app-route] (ecmascript)"));
const errors_2 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/utils/errors.js [app-route] (ecmascript)");
const debug = (0, debug_1.default)('client');
function sortSpaceDelimitedString(str) {
    return str.split(' ').sort().join(' ');
}
class NodeClient extends abstract_client_1.AbstractClient {
    async getClient() {
        if (this.client) {
            return this.client;
        }
        const { config, telemetry: { name, version } } = this;
        const defaultHttpOptions = (_url, options)=>Object.assign(Object.assign({}, options), {
                headers: Object.assign(Object.assign(Object.assign({}, options.headers), {
                    'User-Agent': `${name}/${version}`
                }), config.enableTelemetry ? {
                    'Auth0-Client': Buffer.from(JSON.stringify({
                        name,
                        version,
                        env: {
                            node: process.version
                        }
                    })).toString('base64')
                } : undefined),
                timeout: config.httpTimeout,
                agent: config.httpAgent
            });
        const applyHttpOptionsCustom = (entity)=>{
            entity[openid_client_1.custom.http_options] = defaultHttpOptions;
        };
        applyHttpOptionsCustom(openid_client_1.Issuer);
        let issuer;
        try {
            issuer = await openid_client_1.Issuer.discover(config.issuerBaseURL);
        } catch (e) {
            throw new errors_1.DiscoveryError(e, config.issuerBaseURL);
        }
        applyHttpOptionsCustom(issuer);
        const issuerTokenAlgs = Array.isArray(issuer.id_token_signing_alg_values_supported) ? issuer.id_token_signing_alg_values_supported : [];
        if (!issuerTokenAlgs.includes(config.idTokenSigningAlg)) {
            debug('ID token algorithm %o is not supported by the issuer. Supported ID token algorithms are: %o.', config.idTokenSigningAlg, issuerTokenAlgs);
        }
        const configRespType = sortSpaceDelimitedString(config.authorizationParams.response_type);
        const issuerRespTypes = Array.isArray(issuer.response_types_supported) ? issuer.response_types_supported : [];
        issuerRespTypes.map(sortSpaceDelimitedString);
        if (!issuerRespTypes.includes(configRespType)) {
            debug('Response type %o is not supported by the issuer. Supported response types are: %o.', configRespType, issuerRespTypes);
        }
        const configRespMode = config.authorizationParams.response_mode;
        const issuerRespModes = Array.isArray(issuer.response_modes_supported) ? issuer.response_modes_supported : [];
        if (configRespMode && !issuerRespModes.includes(configRespMode)) {
            debug('Response mode %o is not supported by the issuer. Supported response modes are %o.', configRespMode, issuerRespModes);
        }
        if (config.pushedAuthorizationRequests && !issuer.pushed_authorization_request_endpoint) {
            throw new TypeError('pushed_authorization_request_endpoint must be configured on the issuer to use pushedAuthorizationRequests');
        }
        let jwks;
        if (config.clientAssertionSigningKey) {
            const privateKey = (0, crypto_1.createPrivateKey)({
                key: config.clientAssertionSigningKey
            });
            const jwk = await (0, jose_1.exportJWK)(privateKey);
            jwks = {
                keys: [
                    jwk
                ]
            };
        }
        this.client = new issuer.Client({
            client_id: config.clientID,
            client_secret: config.clientSecret,
            id_token_signed_response_alg: config.idTokenSigningAlg,
            token_endpoint_auth_method: config.clientAuthMethod,
            token_endpoint_auth_signing_alg: config.clientAssertionSigningAlg
        }, jwks);
        applyHttpOptionsCustom(this.client);
        this.client[openid_client_1.custom.clock_tolerance] = config.clockTolerance;
        const issuerUrl = new URL(issuer.metadata.issuer);
        if (config.idpLogout) {
            if (this.config.idpLogout && (this.config.auth0Logout || issuerUrl.hostname.match('\\.auth0\\.com$') && this.config.auth0Logout !== false)) {
                Object.defineProperty(this.client, 'endSessionUrl', {
                    value (params) {
                        const { id_token_hint, post_logout_redirect_uri } = params, extraParams = tslib_1.__rest(params, [
                            "id_token_hint",
                            "post_logout_redirect_uri"
                        ]);
                        const parsedUrl = new URL((0, url_join_1.default)(issuer.metadata.issuer, '/v2/logout'));
                        parsedUrl.searchParams.set('client_id', config.clientID);
                        post_logout_redirect_uri && parsedUrl.searchParams.set('returnTo', post_logout_redirect_uri);
                        Object.entries(extraParams).forEach(([key, value])=>{
                            if (value === null || value === undefined) {
                                return;
                            }
                            parsedUrl.searchParams.set(key, value);
                        });
                        return parsedUrl.toString();
                    }
                });
            } else if (!issuer.end_session_endpoint) {
                debug('the issuer does not support RP-Initiated Logout');
            }
        }
        return this.client;
    }
    async authorizationUrl(parameters) {
        const client = await this.getClient();
        if (this.config.pushedAuthorizationRequests) {
            const { request_uri } = await client.pushedAuthorizationRequest(parameters);
            parameters = {
                request_uri
            };
        }
        return client.authorizationUrl(parameters);
    }
    async callbackParams(req) {
        const client = await this.getClient();
        const obj = client.callbackParams({
            method: req.getMethod(),
            url: req.getUrl(),
            body: await req.getBody()
        });
        return new URLSearchParams(obj);
    }
    async callback(redirectUri, parameters, checks, extras) {
        const params = Object.fromEntries(parameters.entries());
        const client = await this.getClient();
        try {
            return await client.callback(redirectUri, params, checks, extras);
        } catch (err) {
            if (err instanceof openid_client_1.errors.OPError) {
                throw new errors_1.IdentityProviderError(err);
            } else if (err instanceof openid_client_1.errors.RPError) {
                throw new errors_1.ApplicationError(err);
            /* c8 ignore next 3 */ } else {
                throw new errors_1.EscapedError(err.message);
            }
        }
    }
    async endSessionUrl(parameters) {
        const client = await this.getClient();
        return client.endSessionUrl(parameters);
    }
    async userinfo(accessToken) {
        const client = await this.getClient();
        try {
            return await client.userinfo(accessToken);
        } catch (e) {
            throw new errors_1.UserInfoError(e.message);
        }
    }
    async refresh(refreshToken, extras) {
        const client = await this.getClient();
        try {
            return await client.refresh(refreshToken, extras);
        } catch (e) {
            throw new errors_2.AccessTokenError(errors_2.AccessTokenErrorCode.FAILED_REFRESH_GRANT, 'The request to refresh the access token failed.', new errors_1.IdentityProviderError(e));
        }
    }
    generateRandomCodeVerifier() {
        return openid_client_1.generators.codeVerifier();
    }
    generateRandomNonce() {
        return openid_client_1.generators.nonce();
    }
    calculateCodeChallenge(codeVerifier) {
        return openid_client_1.generators.codeChallenge(codeVerifier);
    }
    async getIssuerMetadata() {
        const { issuer } = await this.getClient();
        return issuer.metadata;
    }
}
exports.NodeClient = NodeClient;
const clientGetter = (telemetry)=>{
    let client;
    return async (config)=>{
        if (!client) {
            client = new NodeClient(config, telemetry);
        }
        return client;
    };
};
exports.clientGetter = clientGetter; //# sourceMappingURL=node-client.js.map
}}),
"[project]/node_modules/@auth0/nextjs-auth0/dist/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.handleAuth = exports.handleProfile = exports.handleCallback = exports.handleLogout = exports.handleLogin = exports.withPageAuthRequired = exports.withApiAuthRequired = exports.touchSession = exports.getAccessToken = exports.updateSession = exports.getSession = exports.initAuth0 = void 0;
const tslib_1 = __turbopack_require__("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const crypto_1 = tslib_1.__importDefault(__turbopack_require__("[externals]/crypto [external] (crypto, cjs)"));
const init_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/init.js [app-route] (ecmascript)");
const instance_check_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/utils/instance-check.js [app-route] (ecmascript)");
const node_client_1 = __turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/auth0-session/client/node-client.js [app-route] (ecmascript)");
const genId = ()=>crypto_1.default.randomBytes(16).toString('hex');
let instance;
// For using managed instance with named exports.
function getInstance() {
    (0, instance_check_1.setIsUsingNamedExports)();
    if (instance) {
        return instance;
    }
    instance = (0, init_1._initAuth)({
        genId,
        clientGetter: node_client_1.clientGetter
    });
    return instance;
}
// For creating own instance.
const initAuth0 = (params)=>{
    (0, instance_check_1.setIsUsingOwnInstance)();
    const _a = (0, init_1._initAuth)({
        genId,
        params,
        clientGetter: node_client_1.clientGetter
    }), { withMiddlewareAuthRequired } = _a, publicApi = tslib_1.__rest(_a, [
        "withMiddlewareAuthRequired"
    ]);
    return publicApi;
};
exports.initAuth0 = initAuth0;
const getSession = (...args)=>getInstance().getSession(...args);
exports.getSession = getSession;
const updateSession = (...args)=>getInstance().updateSession(...args);
exports.updateSession = updateSession;
const getAccessToken = (...args)=>getInstance().getAccessToken(...args);
exports.getAccessToken = getAccessToken;
const touchSession = (...args)=>getInstance().touchSession(...args);
exports.touchSession = touchSession;
const withApiAuthRequired = (...args)=>getInstance().withApiAuthRequired(...args);
exports.withApiAuthRequired = withApiAuthRequired;
exports.withPageAuthRequired = (...args)=>getInstance().withPageAuthRequired(...args);
exports.handleLogin = (...args)=>getInstance().handleLogin(...args);
exports.handleLogout = (...args)=>getInstance().handleLogout(...args);
exports.handleCallback = (...args)=>getInstance().handleCallback(...args);
exports.handleProfile = (...args)=>getInstance().handleProfile(...args);
const handleAuth = (...args)=>getInstance().handleAuth(...args);
exports.handleAuth = handleAuth;
tslib_1.__exportStar(__turbopack_require__("[project]/node_modules/@auth0/nextjs-auth0/dist/shared.js [app-route] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),

};

//# sourceMappingURL=node_modules_%40auth0_nextjs-auth0_dist_dc5aa1._.js.map